<!DOCTYPE html>
<html lang="ru-RU">

<head>
  <meta charset="UTF-8">
  <title>"Щи: симулятор жестокости" или "Как не надо делать игры" | Nooby Games</title>
  <link rel="stylesheet" href="./Page_files/style.css" type="text/css" media="all">
</head>

<body class="single-post">
  <!-- BEGIN WAYBACK TOOLBAR INSERT -->
  <div class="wrapper">

    <div>
      <figure class="wp-caption-text">
        <img src="./Page_files/обложка-1.jpg">
      </figure>
    </div>
    <h1>«Щи: симулятор жестокости» или «Как не надо делать игры»</h1>

    <div class="entry-content">
      <p>Данная статья будет полезна начинающим разработчикам игр, да и вообще, любым людям, кто хочет связать
        свою жизнь с программированием. Я постарался сделать статью интересной и полезной тем, кто не знает
        программирование, но знание хотя бы основ С++ увеличит удовольствие от статьи.</p>
      <h1>Предыстория</h1>
      <p>Я всегда мечтал разрабатывать игры. Еще будучи школьником первых классов после школы приходил к другу
        домой и до позднего вечера мы играли в Sega. Тогда «восьмибитка» была для меня просто мечтой. А придя
        домой после таких посиделок рисовал в тетрадях в клеточку карты для Battle City (танчики, кто не
        помнит).</p>
      <p>Прошло время и у нас в семье появился компьютер. В основном, конечно же, я проводил время играя в
        игры, а не разрабатывая их. Но к началу восьмого класса решил твердо заняться игростроем. Информации в
        голове было ноль. Знал только отдаленно, что такое «С++», и мог писать описания к своим выдумкам вроде
        «домики набигают».</p>
      <h3>Первые потуги</h3>
      <p>Купил себе книжку «С++ для чайников». От нее у меня, если честно, болела голова. Не советую новичкам
        данную книгу, так как…эмм…до сих пор как вспоминаю, что читаешь, и все время теряется ответ на простой
        вопрос: «А зачем все это?». Все эти функции, классы, наследование, полиморфизм… Кстати, если Вы
        преподаватель, задумайтесь над тем, даете ли Вы ответ на вопрос «зачем?», отсутствие ответа на этот
        вопрос — это наша общая беда в сфере образования.</p>
      <p>Однако, кое-какие результаты были достигнуты. Я поставил бесплатную нубскую IDE Dev-Cpp от компании
        Bloodshed, как и советовалось в книге, и начал писать программы. Было интересно. Все первые программы,
        конечно же, были консольными, о формошлепстве я тогда и знать не знал.</p>
      <p>Сначала был реализован обычный калькулятор, с расширенными опциями вроде подсчета суммы натурального
        ряда от 1 до N, подсчета суммы сумм натуральных рядов от 1 до N, сумм сумм сумм (я был помешан на
        этом) и т.д. Я назвал его «Пидрахуй», что на украинском значит «Посчитай». Он даже вроде бы что-то
        выводил в текстовый файл. В целом это было около полутора тысяч строк редкостного говнокода,
        основанного на дергании потоков ввода/вывода std::cin и std::cout.</p>
      <p>Потом была программа «Химик», считающая молярную массу любого соединения. С адским вводом молекулы.
        Вся таблица Менделеева хранилась в…а, не, ни хрена. Нигде она не хранилась. Было порядка 130 условных
        конструкций, проверяющих символьное обозначение элемента из входного потока. Потом это дело (молярная
        масса элемента) умножалось на количество атомов в молекуле….и, вуаля! Тем не менее, пару-тройку лаб по
        химии с помощью этого чуда инженерной мысли я сделал.</p>
      <p>Затем я купил книгу по Borland C++, помацал эту IDE, сделал мини-плеер «Balalaika» с плейлистом на 1
        файл, и мне стало скучно. И я забросил все это дело на полтора года.</p>
      <h3>Вторые потуги</h3>
      <p>Через полтора года у меня опять начали возникать амбиции. «Как так, люди вон Oblivion целый сделали,
        а чем я хуже?». И начались поиски инфы про то, как делать игры. Я вообще тогда ничего не понимал, что
        такое игровой движок, игровая механика…В итоге все уперлось в то, что мне пару раз попадались паленые
        версии Visual Studio 2008 на DVD носителях, в которых даже простейшие примеры из Интернета не хотели
        собираться. То отсутствовали стандартные заголовочные файлы, то еще что-то. Для меня это был дикий
        лес, а панель свойств проекта в студии — панелью управления атомной подлодкой.</p>
      <p>И вот, с третьего раза мне посчастливилось купить диск с нормальной студией. Не помню каким образом,
        но я наткнулся на движок <a href="http://www.gamedev.ru/community/hge/" target="_blank" rel="noopener">HGE</a>,
        скачал библиотеку, все подключил, запустил пример из первого
        туториала и завизжал от радости. Передо мной был черный экран. Он был прекрасен как квадрат Малевича.
        Но, оно, зараза, запустилось! Работает!</p>
      <p>И тут Остапа понесло. Сразу скажу, на тот момент из синтаксических конструкций С++, которые я знал,
        были</p>
      <ol>
        <li>Создание переменных</li>
        <li>Условные ветвления</li>
        <li>Циклы</li>
        <li>Функции, которые влом было плодить</li>
      </ol>
      <p>Всё! Какие там классы, зачем они вообще нужны (привет, <a
          href="https://www.google.com/search?q=%D0%91%D1%80%D0%B8%D1%82%D0%B2%D0%B0+%D0%9E%D0%BA%D0%BA%D0%B0%D0%BC%D0%B0"
          target="_blank" rel="noopener">бритва Оккама</a>)? Я решил забацать что-то эпичное!..</p>
      <p>Мы с другом круглый год пытались вдвоем пройти игру под названием <a
          href="https://www.google.com/search?q=Seal+Hunter" target="_blank" rel="noopener">Seal Hunter</a>. Суть
        такова: из-за левой части экрана набегают тюлени, моржи и
        пингвины, надо было их отстреливать не давая пройти через весь экран. Все это сопровождалось кучами
        брызг крови (которая, как я потом узнал через несколько лет, рендерилась в текстуру и оставалась на
        все время игры), мяском и веселым смехом персонажей. Это чудо было рассчитано на одного/двух игроков
        за одним компьютером. Мы потом даже с другом озвучку сделали, часть которой перекочевала в «Щи». Мы
        про Seal Hunter так и говорили: «пойдем заварим щи!», так что название для своей игры долго
        придумывать не пришлось.</p>
      <p>Мне сильно захотелось сделать клон игры, только на русский мотив: вместо льдины — лес, вместо тюленей
        — зайцы, а вместо чукч в пуховиках — дед в ушанке. И чтоб на двух игроков. И чтоб еще и по сети! И с
        прокачкой. И с кучей оружия, как в «контре», плюс гранатометы. И чтоб кровища аж дрыстала из экрана!
        А, и еще бы бронетехники добавить…<br>
        В общем, насколько Вы поняли, торкнуло меня конкретно. И вот, пошла она…разработка!</p>
      <h1>Первый прототип</h1>
      <p>За, буквально, два дня был написан первый прототип: по зеленому полю вверх-вниз бегал человечек в
        ушанке и с калашом, на него вылетали белые квадратики, автомат ссал пулями по ним и при пересечении с
        квадратиком тот «умирал» (останавливался и становился серым).</p>
      <figure><img src="./Page_files/TECT_1-ДО-500-FPS.jpg" alt="первый прототип">
        <figcaption class="wp-caption-text">Первый прототип с квадратными врагами</figcaption>
      </figure>
      <p>Вау! Это был конкретный прогресс! Но я сразу же столкнулся с несколькими трудностями.</p>
      <p>Во-первых автомат, как я уже сказал, просто <strong>ссал</strong> пулями. Т.е. как будто в него
        набрали воды и он, поперхиваясь, выплевывал пули: то две за раз, то одну, то три…Все дело было в том,
        как я рассчитывал скорострельность: брал по модулю текущую миллисекунду системных часов компьютера от
        125. Т.е. если текущая миллисекунда компьютера делится на 125 без остатка, то автомат
        «разблокировывался» после последнего выстрела и можно была снова выстрелить. Недолго думая, я
        догадался, что дело в том, что игра работает кадрами. Т.е. проверка вызывается в целом случайное
        количество раз за секунду, и явно не каждую миллисекунду, из-за чего я «промахивался» мимо
        миллисекунд, когда можно было разблокировать автомат. Я понял причину, но пока оставил это дело в
        покое. Была еще одна проблема.</p>
      <p>Я столкнулся с тоннельным эффектом. Из-за того, что игра работает кадрами, пуля телепортировалась по
        экрану и очень часто не пересекалась с квадратиком врага. В итоге врага было сложно убить, что мне
        очень не нравилось. Про <a href="https://www.google.com/search?q=continuous+collision+detection" target="_blank"
          rel="nofollow noopener">CCD</a> я тогда тоже и знать не знал, хотя догадывался, что
        нужно каждый кадр строить прямую между текущей позицией пули и прошлой (из прошлого кадра) и проверять
        уже эту линию на пересечение с квадратиком. Но это был для меня тогда жуткий матан, дико не хотелось в
        это лезть.</p>
      <p>Кстати, пуля была одна! Я ее просто быстро гонял по экрану, и при попадании за экран она
        телепортировалась назад в ствол. Я подогнал ее скорость, чтобы она успевала залетать за экран и, таким
        образом «сэкономил память» (facepalm).</p>
      <p>Как видите, с самого начала я столкнулся с трудностями, которые, по-хорошему, требовали исследования
        и копания в документации и обучающих статьях. Но, мне было лень. Если честно после недели разработки
        запал пропал, так как я начал тонуть в болоте навалившихся сложностей. В говнокоде я еще не тонул, не,
        это была пока лужица цифровых экскрементов из множества глобальных переменных и нескольких объемных
        функций.</p>
      <p>Далее, я уже не помню, что происходило, но мне захотелось добавить:</p>
      <ul>
        <li>оружия;</li>
        <li>разных врагов;</li>
        <li>разнообразия смерти врагов;</li>
        <li>сделать нормальную скорострельность и перезарядку;</li>
        <li>добавить второго игрока.</li>
      </ul>
      <h1>Симуляция жестокости</h1>
      <p>Ну все, далее пошло-поехало!</p>
      <p>Я сразу добавил поддержку второго игрока, так как знал, что чем дальше, тем это сделать будет
        сложней. Воистину, хоть одно мудрое решение! Но…</p>
      <h3>Поддержка двух игроков</h3>
      <p>За игрока и его игровое окружение отвечали некоторое множество переменных. Это:</p>
      <pre>float x=1000.0f, y=450.0f;// игрок 1, координаты
float dx=0.0f, dy=0.0f;   //и все что нужно для его движения
const float tormoz=0.89f;
...
int kills;                //количество убитых
int points1=0;            //очки за убийства, за которые покупается оружие
...
hgeSprite* pulya;         //картинка огоня от пули
hgeSprite* p;             //картинка самой пули
...
float a;                  //координаты огня пули игрока 1
float b;
int oboima;               //кол-во пуль в обойме игрока 1
int oboima_akt;           //уже не помню что, по-моему альтернативная обойма (подствольник)
int aktivatorp=0;         //отвечает за статус пули, 1 - летит, 0 - в обойме
...
int N_WEAPON1=1;          //номер текущего оружия в руках игрока
int shot=0;               //можно ли выстрелить? 0 - можно, 1 - нельзя (скорострельность)
</pre>
      <p>Ха, я сказал некоторое множество? Да этих переменных куча! Все, что Вы видите выше — это всего лишь
        малая, самая важная часть. Самое плохое, что они были размазаны равномерным слоем по нескольким стам
        строкам кода…</p>
      <p>Итак, что же я сделал? Правильно — скопировал переменные и добавил суффикс «2»!</p>
      <pre>float x2=1000.0f, y2=450.0f;// игрок 2, координаты
float dx2=0.0f, dy2=0.0f;   //и все что нужно для его движения
const float tormoz2=0.89f;  //непонятно, зачем игроку 2 отдельный тормоз?
...
int kills2;                //количество убитых
int points2=0;            //очки за убийства, за которые покупается оружие
...
hgeSprite* pulya2;         //картинка огоня от пули
hgeSprite* p2;             //картинка самой пули
...
float a;2                  //координаты огня пули игрока 2
float b2;
int oboima2;               //кол-во пуль в обойме игрока 2
int oboima_akt2;           //уже не помню что, по-моему альтернативная обойма (подствольник)
int aktivatorp2=0;         //отвечает за статус пули, 1 - летит, 0 - в обойме
...
int N_WEAPON2=1;          //номер текущего оружия в руках игрока
int shot2=0;               //можно ли выстрелить? 0 - можно, 1 - нельзя (скорострельность)</pre>
      <p>Может новички не в курсе, но правильнее было бы сделать структуру данных и просто создать новый
        объект этой структуры. Всего одна лишняя строчка кода вместо сотни!</p>
      <p>Отдельно хочу сказать про переменную <em>tormoz</em>. Механика игры такова, что при передвижении
        скорость игрока как бы затухает, т.е. она постоянно умножается (в каждом кадре) на эту переменную, и,
        в итоге, сводится к нулю. Появляется небольшой эффект скольжения. Я не помню, зачем я это сделал. То
        ли потому, что в Seal Hunter данное скольжение было частью геймплея и усложняло игру, то ли просто
        взял код из туториала по HGE и бездумно скопировал механику.</p>
      <p>Как видите, куча глобальных переменных, сопровождение такого кода быстро превращается в сущий ад…Ну
        да ладно, это еще ничего.</p>
      <h3>Добавление нового оружия</h3>
      <figure style="width: 150px" class="alignright">
        <img src="./Page_files/panzerfaust3.png" alt="panzerfaust3">
        <figcaption class="wp-caption-text">Panzerfaust 3 — самое грозное и дорогое оружие в игре</figcaption>
      </figure>
      <p>Добавление новых видов оружия тоже не сулило ничего хорошего, так как на каждый вид оружия
        предназначалось свое множество глобальных переменных: это звуковой эффект выстрела, звуковой эффект
        перезарядки, таймер перезарядки, общее время перезарядки, общее максимальное количество пуль в обойме,
        количество текущих пуль в обойме, альтернативная обойма (например, подствольник у автомата) —
        максимальное и текущее количество пуль и ее перезарядка, скорость пули, мощность пули (сколько врагов
        прошивает насквозь), урон пули, координаты оружия относительно игрока, картинка (спрайт) оружия,
        картинка обвеса (подствольника, если есть), стоимость оружия, признак покупки данного оружия игроком,
        множитель опыта для данного оружия, множитель очков для данного оружия (чем легче убить — тем меньше
        множитель). И еще много чего, чего я уже и не перечислю.</p>
      <p>Напомню, все это глобальные, черт возьми, переменные. Для каждого игрока. Для каждого, черт возьми,
        вида оружия. Ой, т.е. для каждого <strong>наименования</strong> оружия, Вы не подумайте, что я говорю
        про пистолеты/автоматы/гранаты. А наименований оружия у меня было много:</p>
      <pre>hgeSprite* ak47;//автомат
hgeSprite* pm;//пистолет Макарова
hgeSprite* pp19_vityaz; //ПП 19-01 "Витязь"
hgeSprite* fn_f2000;//ФН_Ф2000
hgeSprite* tt;//Тульский Токарев 
hgeSprite* rpk;//РПК 74
hgeSprite* mac;//MAC 1 
hgeSprite* winchester; //винчестер
hgeAnimation* winchester_anime;
hgeSprite* rpk47;//РПК 47
hgeSprite* glok;//GLOK
hgeSprite* rgd5;//РГД-5
hgeAnimation* katana1_anime;
hgeSprite* milkor;//Milkor MGL
hgeSprite* panzer;//Panzerfaust-3
hgeSprite* webley;//Webley MK 4
hgeSprite* fn_five_seven;//FN Five-Seven</pre>
      <p>Особенно умиляет <em>katana1_animе</em>. Т.е. подразумевалось, что катана будет не одна, их будет
        несколько. Вот так простор для развития игры!</p>
      <p>Да и набор оружия какой-то трешовый. Здесь представлены почти все категории оружия, которые я хотел
        добавить в игру: пистолеты, револьверы, дробовики, винтовки, пулеметы, гранатометы, гранаты, холодное
        оружие. Не успел добавить еще снайперские винтовки и бензопилы. Но в игре присутствует всего по
        одному-два наименования на категорию. Догадываетесь почему?</p>
      <p>Добавление нового оружия занимало у меня пол дня: надо было найти оружие в Интернете, информацию про
        его боевые характеристики (у меня был настоящий реализм!), скачать и отфотошопить текстуру оружия (я
        придавал ему мультяшный вид добавляя черную окантовку), затем надо было добавить в несколько мест по
        всей программе новые переменные, затем надо было протестировать оружие и откалибровать значения до
        приемлемых, чтобы было играбельно и не выглядело отвратно (я про координаты картинки оружия).</p>
      <p>В полную меру ужасная структура проекта проявилась при добавлении первого дробовика:</p>
      <pre>hgeSprite* p1d1;//спрайты дробинок для дробовиков игрока 1 и игрока 2
hgeSprite* p1d2;//по 4 дробинки на дробовик, итого с основной пулей - 5
hgeSprite* p1d3;
hgeSprite* p1d4;
hgeSprite* p2d1;
hgeSprite* p2d2;
hgeSprite* p2d3;
hgeSprite* p2d4;

//дробь
float p1d1x,p1d1y;
float p1d2x,p1d2y;
float p1d3x,p1d3y;
float p1d4x,p1d4y;
//дробь 2 (сиквел, ага)
float p2d1x,p2d1y;
float p2d2x,p2d2y;
float p2d3x,p2d3y;
float p2d4x,p2d4y;

int aktivatorp1d1=0;//0 - дробина в стволе, 1 - летит
int aktivatorp1d2=0;
int aktivatorp1d3=0;
int aktivatorp1d4=0;</pre>
      <p>В общем, всего 5 дробинок, а сколько фана! Я уже не говорю про анимацию цевья дробовика, когда после
        выстрела надо было делать таймаут и перезарядку с проигрыванием анимации. Помню, я маялся с дробовиком
        больше недели.</p>
      <h3>Перезарядка оружия</h3>
      <p>Перезарядка — отдельная тема. Здесь мы имеем дело с временем. С определением которого у меня были
        проблемы — достаточно вспомнить про баг&nbsp; со скорострельностью. Перед тем как показать код таймера
        перезарядки покажу-ка я Вам сначала отдачу от оружия. Да, у меня была отдача — чисто графически она
        выглядела как подергивание оружия вверх и назад при выстреле, на самом деле при выстреле я на
        мгновение (один кадр) менял координаты отрисовки:</p>
      <pre>if(oboima&gt;0) //если вообще что-то есть в обойме
//эти комментарии я добавил сейчас, если что, в оригинале их просто нет
&nbsp;&nbsp; &nbsp;{
    //для каких-то стволов дергаемся по Х на 1 пиксель
&nbsp;&nbsp; &nbsp;if(N_WEAPON1==1||N_WEAPON1==9||N_WEAPON1==15)
&nbsp;&nbsp; &nbsp;{weapon_x1[N_WEAPON1]++;
&nbsp;&nbsp; &nbsp;weapon_x2[N_WEAPON1]++;}
&nbsp;&nbsp; &nbsp;if(N_WEAPON1==4)//а для каких-то еще и вверх
&nbsp;&nbsp; &nbsp;{weapon_x1[N_WEAPON1]++;
&nbsp;&nbsp; &nbsp;weapon_y1[N_WEAPON1]--;
&nbsp;&nbsp; &nbsp;weapon_y2[N_WEAPON1]--;&nbsp;&nbsp; &nbsp;}
&nbsp;&nbsp; &nbsp;if(N_WEAPON1==14)//а тут вообще супер-отдача!!!
&nbsp;&nbsp; &nbsp;{weapon_x1[N_WEAPON1]+=2;
&nbsp;&nbsp; &nbsp;weapon_y1[N_WEAPON1]--;
&nbsp;&nbsp; &nbsp;weapon_x2[N_WEAPON1]++;
&nbsp;&nbsp; &nbsp;weapon_y2[N_WEAPON1]--;}
&nbsp;&nbsp; &nbsp;}
    //за отступы не ругайте - я сохранил их первозданность
&nbsp;&nbsp;&nbsp; if(oboima&gt;0&amp;&amp;p_vistrel!=0)//если есть что-то в обойме при нажатии выстрела
&nbsp;&nbsp; &nbsp;{fire1();//здесь я вынес в функцию (как я мог!!!) код рисующий клубок огня на конце ствола
&nbsp;&nbsp; &nbsp;p_ogon_ms=GetTime();//это таймер горения огня, он горит больше 1 кадра
&nbsp;&nbsp; &nbsp;p_ogon_s=perez_akt;
&nbsp;&nbsp; &nbsp;p_vistrel=0;}</pre>
      <p>Если Вас еще не тошнит, вот типичный код просчета перезарядки:</p>
      <pre>if(N_WEAPON2==3)//для FN F-2000 (850 мс)
{
if(vistrel2_time&lt;928) //если честно, я сам сейчас не понимаю ничего {if((GetTime()&gt;=vistrel2_time+72)||(GetTime()&lt;vistrel2_time&amp;&amp;perez_akt!=vistrel2_time_sec)) {p_vistrel2=1;} } if(vistrel2_time&gt;=928&amp;&amp;GetTime()&gt;vistrel2_time-928&amp;&amp;perez_akt!=vistrel2_time_sec)
{p_vistrel2=1;}
}</pre>
      <p>Выше был представлен код перезарядки FN F2000, довольно козырная штука по игре, это единственное
        оружие у которого было видимое перекрестие прицела (да, игра еще была и хардкорная!). Так вот,
        обрабатывается два случая — когда миллисекунда времени выстрела далека от тысячи, и когда она близка к
        тысяче, тем самым надо разблокировать оружие на какой-то миллисекунде следующей секунды. А у меня
        хранятся только миллисекунды. В итоге имеем вот такую вот необходимость делать проверки. Причем,
        насколько я помню, все это с учетом лагов и разбиения времени кадрами.</p>
      <p>А теперь та же самая перезарядка, но уже в функции рендера (вывода данных на экран). Я обозначал
        перезарядку простым прогресс баром из трех тире, заключенных в квадратные скобки.</p>
      <pre>//ВЫВОД ПРОГРЕССА ПЕРЕЗАРЯДКИ ИГРОКА 1
&nbsp;&nbsp; &nbsp;if(reload==true)
&nbsp;&nbsp; &nbsp;{&nbsp; &nbsp;
&nbsp;&nbsp; &nbsp;//какое-то оружие, чья перезарядка около трех секунд
    //опять имеем дело с секундами от 0-57 и отдельно с 58-59
&nbsp;&nbsp; &nbsp;if(N_WEAPON1==0||N_WEAPON1==3||N_WEAPON1==5||N_WEAPON1==8)
&nbsp;&nbsp; &nbsp;{
&nbsp;&nbsp; &nbsp;if(perez_time&gt;reload_time[N_WEAPON1]) //если секунда от 0 до 57
&nbsp;&nbsp; &nbsp;{
&nbsp;&nbsp; &nbsp;if(perez_akt==perez_time-reload_time[N_WEAPON1])
&nbsp;&nbsp; &nbsp;{oboima_text-&gt;printf(x-35+Xz, y-28, HGETEXT_CENTER, "[-&nbsp; ]");}

&nbsp;&nbsp; &nbsp;if((reload_time[N_WEAPON1]%2==0&amp;&amp;perez_akt==perez_time-(reload_time[N_WEAPON1]-reload_time[N_WEAPON1]/2))||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (reload_time[N_WEAPON1]%2!=0&amp;&amp;perez_akt==perez_time-(reload_time[N_WEAPON1]-((reload_time[N_WEAPON1]-1)/2)))||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (reload_time[N_WEAPON1]%2!=0&amp;&amp;perez_akt==perez_time-(reload_time[N_WEAPON1]-((reload_time[N_WEAPON1]+1)/2))))
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp; &nbsp;oboima_text-&gt;printf(x-35+Xz, y-28, HGETEXT_CENTER, "[-- ]");
&nbsp;&nbsp; &nbsp;if(perez_akt_milli==perez_time_milli&amp;&amp;(perez_akt==perez_time-1||perez_akt==59))
&nbsp;&nbsp; &nbsp;{ak_perez2();}
&nbsp;&nbsp; &nbsp;}
&nbsp;&nbsp; &nbsp;
&nbsp;&nbsp; &nbsp;if(perez_akt==perez_time&amp;&amp;perez_akt_milli&lt;perez_time_milli) &nbsp;&nbsp;&nbsp; {oboima_text-&gt;printf(x-35+Xz, y-28, HGETEXT_CENTER, "[---]");}
&nbsp;&nbsp; &nbsp;}
&nbsp;&nbsp; &nbsp;}
    //...код перезарядки по условию if(reload==true) продолжается мно-о-ого строк...</pre>
      <p>Если честно, уже сложно понять, чем <em>perez_time</em> отличается от <em>perez_akt</em>. Скорее
        всего первая переменная хранила время, когда перезарядка должна закончиться, а вторая хранила текущее
        время, по которому активировалась/деактивировалась перезарядка, отсюда такие страшные названия.</p>
      <p>По-хорошему я должен был высчитать глобальное время, когда надо закончить перезарядку и просто
        проверять больше ли или меньше текущее время. Если больше — при первой же возможности (из-за
        покадрового просчета игры мы не знаем, на сколько больше будет время следующего кадра, может быть мы
        вообще зависнем на секунду) заканчиваем перезарядку. Но, тогда бы мне мои сегодняшние мозги…</p>
      <p>Вообще у новичков очень часто основные силы уходят на написание кода, продумывание синтаксических
        конструкций, в то время как бывалые программисты, свободно владеющие любимым языком, больше
        сосредоточены на самой задаче и наиболее легком пути ее решения. Так и должно быть.</p>
      <h3>Разнообразие врагов</h3>
      <p>В игре представлено целых четыре вида врагов, причем, если включен РПГ-мод, у них могли появляться
        руны: тепепортации, иллюзиониста и т.д. Но, обо всем по порядку.</p>
      <p>Зайцы являются базовым врагом, и, хвала какому-то туториалу с сайта HGE, они представлены в виде
        структуры данных (феноменально!), которая представлена ниже. Правда, название структуры, как
        обычно,&nbsp; «не очень».</p>
      <pre>struct zayacObject&nbsp; //ЗАЙЦЫ---------------------
{float v1x,v1y;
int bezuh;
int bezboshki;
int ubit;
int pokoin;//быть покойником и быть убитым - разные вещи!!!
int health;
int killed_by;//ID игрока, которому надо дать очки при убийстве
float timeout_milli,timeout;//таймер респауна
float speed;
int defence;//защита - RPG-мод
float kill_time;
int kill_time_sec;
int object_id;
int A;            //индекс для алгоритма художника
bool vzorvan;&nbsp;&nbsp; &nbsp; //я уже и не помню зачем все это...&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;
float energy;
float rasstX,rasstY;
int chetvert;
int RPG_healer;   //RPG руны
int RPG_illusionist;
float ill1_x,ill1_y,ill2_x,ill2_y; //координаты иллюзий, если это заяц-иллюзионист
int ill1_active,ill2_active;
int RPG_teleporter;
float teleportx;
int teleported;
};
zayacObject*&nbsp;&nbsp; vragi1Objects;</pre>
      <p>Как видите, все не так просто: у нас здесь есть признаки оторванных ушей, оторванной бошки, признак
        убийства… Все еще очень осложняется трешовой игровой механикой, о которой речь ниже. Как и в случае с
        пулями, я гонял одних и тех же зайцев по кругу, пока заяц покойник (int pokoin) и отсчитывался таймер
        (float timeout_milli,timeout;) — он не респаунился. Максимальное число зайцев, да и вообще любых
        объектов,&nbsp; было жестко вшито в игру:</p>
      <pre>#define MAX_ZAYAC 29//Здесь мы видим, что зайцев всего было не более 29 штук
#define MAX_VOLK 20
#define MAX_MEDVED 20
#define MAX_PTENEC 20
#define MAX_TRUPS 5000
#define MAX_UHI 200
#define MAX_BLOOD 500
#define MAX_HEAD 200
#define MAX_GILZ 200
#define MAX_BONUS 200
#define MAX_BONUSTEXT 200
#define MAX_BONUSI 200
#define MAX_BONUSSTATUS 50
#define MAX_MYASO 2000
#define MAX_GREN 100
#define MAX_KILLS 100000</pre>
      <p>По указателю создавался массив с жестко заданным размером. О динамическом выделении памяти из кучи я
        тогда и знать не знал, для меня и этот кусок кода из туториала было чем-то крутым и адски удобным.</p>
      <figure style="width: 120px" class="alignright">
        <img src="./Page_files/1.bmp">
        <figcaption class="wp-caption-text">Волк, на анимацию которого ( из 7 кадров) было убито порядка двух
          дней. При с рисовкой мне помогал мой друг.</figcaption>
      </figure>
      <p>Далее было решено добавить волков и медведей. Причем это не просто враги с разными характеристиками,
        они кооперировались с зайцами и выполняли свою роль. Волки ускоряли близлежащих зайцев (эдак раза в
        полтора-два), в то время как за медведем можно было просто спрятаться — никакая пуля не прошивала его
        насквозь. Если зайцы были немного ниже или выше медведя, они подбегали и выстраивались за ним в
        очередь.</p>
      <p>А теперь я выкладываю структуру данных для волков.</p>
      <pre>struct volkObject //ВОЛКИ----------------------
{
float v2x,v2y;
int ubit;
int health;
int killed_by;
float timeout_milli,timeout;
float speed;
int defence;
int object_id;
int RPG_healer;
int RPG_illusionist;
float ill1_x,ill1_y,ill2_x,ill2_y;
int ill1_active,ill2_active;
int RPG_teleporter;
float teleportx,teleporty;
int teleported;
};

volkObject* vragi2Objects;</pre>
      <p>Найдите 10 отличий от структуры данных зайцев. Такое же дело и для медведей, и для птенцов.
        Наследование? Не, не слышал. Вообще игра по сути написана на С, разве что компилировалась в настройках
        как С++.</p>
      <p>Для каждого вида врага код начинался с чего? Правильно, с просчета попадания пули по врагу — это же
        шутер! Кстати, интересный момент: я еще тогда задумывался, как правильнее — расчет попадания в коде
        пули (для каждой пули), или просчет попадания для каждого врага (как здесь). С одной стороны первый
        подход правильнее, если нет никакой сильной разницы при попадании в разных врагов. Но тут как раз
        разница была. Зайцу можно было отстрелить уши и оторвать голову, волку — ничего, его судьба миловала,
        а вот медведю можно было тоже оторвать голову — но там требовался гранатомет.</p>
      <p>Просчет поведения врагов и попадания в них занимает львиную долю кода. Чтобы Вы представляли, что в
        нем творится, предлагаю взглянуть на условие попадания в зайца и отрыва ушей:</p>
      <pre>//коцанье зайца (отрывание ушей)
if(((((py&lt;=vragi1Objects[i3].v1y+12&amp;&amp;py&gt;vragi1Objects[i3].v1y&amp;&amp;px&lt;vragi1Objects[i3].v1x)||
&nbsp;&nbsp; &nbsp; (p1d1y&lt;=vragi1Objects[i3].v1y+12&amp;&amp;p1d1y&gt;vragi1Objects[i3].v1y&amp;&amp;p1d1x&lt;vragi1Objects[i3].v1x)||
&nbsp;&nbsp;&nbsp;&nbsp; (p1d2y&lt;=vragi1Objects[i3].v1y+12&amp;&amp;p1d2y&gt;vragi1Objects[i3].v1y&amp;&amp;p1d2x&lt;vragi1Objects[i3].v1x)||
&nbsp;&nbsp;&nbsp;&nbsp; (p1d3y&lt;=vragi1Objects[i3].v1y+12&amp;&amp;p1d3y&gt;vragi1Objects[i3].v1y&amp;&amp;p1d3x&lt;vragi1Objects[i3].v1x)||
&nbsp;&nbsp;&nbsp;&nbsp; (p1d4y&lt;=vragi1Objects[i3].v1y+12&amp;&amp;p1d4y&gt;vragi1Objects[i3].v1y&amp;&amp;p1d4x&lt;vragi1Objects[i3].v1x))&amp;&amp; &nbsp;&nbsp; &nbsp; aktivatorp==1&amp;&amp;x-55&gt;vragi1Objects[i3].v1x&amp;&amp;vragi1Objects[i3].bezuh==0&amp;&amp;vragi1Objects[i3].ubit!=1)||
(((p2y&lt;=vragi1Objects[i3].v1y+12&amp;&amp;p2y&gt;vragi1Objects[i3].v1y&amp;&amp;p2x&lt;vragi1Objects[i3].v1x)||
&nbsp;(p2d1y&lt;=vragi1Objects[i3].v1y+12&amp;&amp;p2d1y&gt;vragi1Objects[i3].v1y&amp;&amp;p2d1x&lt;vragi1Objects[i3].v1x)||
&nbsp;(p2d2y&lt;=vragi1Objects[i3].v1y+12&amp;&amp;p2d2y&gt;vragi1Objects[i3].v1y&amp;&amp;p2d2x&lt;vragi1Objects[i3].v1x)||
&nbsp;(p2d3y&lt;=vragi1Objects[i3].v1y+12&amp;&amp;p2d3y&gt;vragi1Objects[i3].v1y&amp;&amp;p2d3x&lt;vragi1Objects[i3].v1x)||
&nbsp;(p2d4y&lt;=vragi1Objects[i3].v1y+12&amp;&amp;p2d4y&gt;vragi1Objects[i3].v1y&amp;&amp;p2d4x&lt;vragi1Objects[i3].v1x))&amp;&amp; &nbsp;aktivatorp2==1&amp;&amp;x2-55&gt;vragi1Objects[i3].v1x&amp;&amp;vragi1Objects[i3].bezuh==0&amp;&amp;vragi1Objects[i3].ubit!=1))||
&nbsp;(katana1_anime-&gt;IsPlaying()==true&amp;&amp;vragi1Objects[i3].v1x&gt;x-90&amp;&amp;y&lt;vragi1Objects[i3].v1y+12&amp;&amp;y&gt;vragi1Objects[i3].v1y&amp;&amp;
&nbsp;x-55&gt;vragi1Objects[i3].v1x&amp;&amp;vragi1Objects[i3].bezuh==0&amp;&amp;vragi1Objects[i3].ubit!=1))
//vragi1Objects[i3].bezuh==0 чтобы ухи не возвращались на место после повторного попадания зайцу по "ушам"
{


uhiObjects[N_UHI].niz=vragi1Objects[i3].v1y+38;
vragi1Objects[i3].bezuh=1;
uhiObjects[N_UHI].uhix=vragi1Objects[i3].v1x+18;
uhiObjects[N_UHI].uhiy=vragi1Objects[i3].v1y-3;
uhiObjects[N_UHI].akt=1;

if((((py&lt;=vragi1Objects[i3].v1y+12&amp;&amp;py&gt;vragi1Objects[i3].v1y&amp;&amp;px&lt;vragi1Objects[i3].v1x)||
&nbsp;&nbsp; &nbsp; (p1d1y&lt;=vragi1Objects[i3].v1y+12&amp;&amp;p1d1y&gt;vragi1Objects[i3].v1y&amp;&amp;p1d1x&lt;vragi1Objects[i3].v1x)||
&nbsp;&nbsp;&nbsp;&nbsp; (p1d2y&lt;=vragi1Objects[i3].v1y+12&amp;&amp;p1d2y&gt;vragi1Objects[i3].v1y&amp;&amp;p1d2x&lt;vragi1Objects[i3].v1x)||
&nbsp;&nbsp;&nbsp;&nbsp; (p1d3y&lt;=vragi1Objects[i3].v1y+12&amp;&amp;p1d3y&gt;vragi1Objects[i3].v1y&amp;&amp;p1d3x&lt;vragi1Objects[i3].v1x)||
&nbsp;&nbsp;&nbsp;&nbsp; (p1d4y&lt;=vragi1Objects[i3].v1y+12&amp;&amp;p1d4y&gt;vragi1Objects[i3].v1y&amp;&amp;p1d4x&lt;vragi1Objects[i3].v1x))&amp;&amp; &nbsp;&nbsp; &nbsp; aktivatorp==1&amp;&amp;x-55&gt;vragi1Objects[i3].v1x)||
&nbsp;(katana1_anime-&gt;IsPlaying()==true&amp;&amp;vragi1Objects[i3].v1x&gt;x-90&amp;&amp;y&lt;vragi1Objects[i3].v1y+12&amp;&amp;y&gt;vragi1Objects[i3].v1y&amp;&amp;
&nbsp;x-55&gt;vragi1Objects[i3].v1x&amp;&amp;vragi1Objects[i3].bezuh==0&amp;&amp;vragi1Objects[i3].ubit!=1))
{points1+=10;}//10 очков за уши игроку 1
if(((p2y&lt;=vragi1Objects[i3].v1y+12&amp;&amp;p2y&gt;vragi1Objects[i3].v1y&amp;&amp;p2x&lt;vragi1Objects[i3].v1x)||
&nbsp;(p2d1y&lt;=vragi1Objects[i3].v1y+12&amp;&amp;p2d1y&gt;vragi1Objects[i3].v1y&amp;&amp;p2d1x&lt;vragi1Objects[i3].v1x)||
&nbsp;(p2d2y&lt;=vragi1Objects[i3].v1y+12&amp;&amp;p2d2y&gt;vragi1Objects[i3].v1y&amp;&amp;p2d2x&lt;vragi1Objects[i3].v1x)||
&nbsp;(p2d3y&lt;=vragi1Objects[i3].v1y+12&amp;&amp;p2d3y&gt;vragi1Objects[i3].v1y&amp;&amp;p2d3x&lt;vragi1Objects[i3].v1x)||
&nbsp;(p2d4y&lt;=vragi1Objects[i3].v1y+12&amp;&amp;p2d4y&gt;vragi1Objects[i3].v1y&amp;&amp;p2d4x&lt;vragi1Objects[i3].v1x))&amp;&amp; &nbsp;aktivatorp2==1&amp;&amp;x2-55&gt;vragi1Objects[i3].v1x)
{points2+=10;}//10 очков за уши игроку 2

N_UHI++;

if(N_UHI&gt;=MAX_UHI-1)
{N_UHI=0;}

}//закрытие коцанья зайца</pre>
      <p>Сейчас сразу видно (или не сразу?), что вот эти безумные условия можно было как минимум сохранить в
        переменных, и затем не писать их заново, как это делается в полностью аналогичных проверках попадания
        по ушам и проверки, какому же игроку достанется несчастные 10 очков. С этим фрагментом кода в свое
        время был связан веселый баг (кстати, некоторые баги стали фичами, об этом ниже), а именно: при
        попадании по месту, где у зайца были уши, новая пара ушей повторно респаунилась и снова отлетала.
        Особенно круто это выглядело при стрельбе дробовика в упор — с одного выстрела летело по 5 пар ушей,
        как из рога изобилия. Жалко, но этот баг пришлось убрать, так как он выглядел нелогичным. А вот один
        баг был-таки превращен в фичу, о нем будет ниже.</p>
      <p>Далее еще интереснее. Подобный код с проверками попадания в тушку, в голову, по ушам, проверка какой
        игрок попал и т.д. дублировался 4 раза для каждого врага! Вот Вам попадание в медведя с последующим
        разъяснением, какой же игрок все-таки в него попал:</p>
      <pre>if((((p1d1y&lt;vragi3Objects[i80].v3y+200&amp;&amp;p1d1y&gt;vragi3Objects[i80].v3y+105&amp;&amp;p1d1x&lt;=vragi3Objects[i80].v3x+170&amp;&amp;p1d1x&gt;vragi3Objects[i80].v3x-300*lag&amp;&amp;aktivatorp1d1==1)||
&nbsp;&nbsp; (p1d2y&lt;vragi3Objects[i80].v3y+200&amp;&amp;p1d2y&gt;vragi3Objects[i80].v3y+105&amp;&amp;p1d2x&lt;=vragi3Objects[i80].v3x+170&amp;&amp;p1d2x&gt;vragi3Objects[i80].v3x-300*lag&amp;&amp;aktivatorp1d2==1)||
&nbsp;&nbsp; (p1d3y&lt;vragi3Objects[i80].v3y+200&amp;&amp;p1d3y&gt;vragi3Objects[i80].v3y+105&amp;&amp;p1d3x&lt;=vragi3Objects[i80].v3x+170&amp;&amp;p1d3x&gt;vragi3Objects[i80].v3x-300*lag&amp;&amp;aktivatorp1d3==1)||
&nbsp;&nbsp; (p1d4y&lt;vragi3Objects[i80].v3y+200&amp;&amp;p1d4y&gt;vragi3Objects[i80].v3y+105&amp;&amp;p1d4x&lt;=vragi3Objects[i80].v3x+170&amp;&amp;p1d4x&gt;vragi3Objects[i80].v3x-300*lag&amp;&amp;aktivatorp1d4==1)||
&nbsp;&nbsp; (py&lt;vragi3Objects[i80].v3y+200&amp;&amp;py&gt;vragi3Objects[i80].v3y+105&amp;&amp;px&lt;=vragi3Objects[i80].v3x+170&amp;&amp;px&gt;vragi3Objects[i80].v3x-300*lag&amp;&amp;aktivatorp==1))
&nbsp; &amp;&amp;x-55&gt;vragi3Objects[i80].v3x&amp;&amp;vragi3Objects[i80].ubit!=1)||
&nbsp;&nbsp; (((p2d1y&lt;vragi3Objects[i80].v3y+200&amp;&amp;p2d1y&gt;vragi3Objects[i80].v3y+105&amp;&amp;p2d1x&lt;=vragi3Objects[i80].v3x+170&amp;&amp;p2d1x&gt;vragi3Objects[i80].v3x-300*lag&amp;&amp;aktivatorp2d1==1)||
&nbsp;&nbsp; (p2d2y&lt;vragi3Objects[i80].v3y+200&amp;&amp;p2d2y&gt;vragi3Objects[i80].v3y+105&amp;&amp;p2d2x&lt;=vragi3Objects[i80].v3x+170&amp;&amp;p2d2x&gt;vragi3Objects[i80].v3x-300*lag&amp;&amp;aktivatorp2d2==1)||
&nbsp;&nbsp; (p2d3y&lt;vragi3Objects[i80].v3y+200&amp;&amp;p2d3y&gt;vragi3Objects[i80].v3y+105&amp;&amp;p2d3x&lt;=vragi3Objects[i80].v3x+170&amp;&amp;p2d3x&gt;vragi3Objects[i80].v3x-300*lag&amp;&amp;aktivatorp2d3==1)||
&nbsp;&nbsp; (p2d4y&lt;vragi3Objects[i80].v3y+200&amp;&amp;p2d4y&gt;vragi3Objects[i80].v3y+105&amp;&amp;p2d4x&lt;=vragi3Objects[i80].v3x+170&amp;&amp;p2d4x&gt;vragi3Objects[i80].v3x-300*lag&amp;&amp;aktivatorp2d4==1)||
&nbsp;&nbsp; (p2y&lt;vragi3Objects[i80].v3y+200&amp;&amp;p2y&gt;vragi3Objects[i80].v3y+119&amp;&amp;p2x&lt;=vragi3Objects[i80].v3x+170&amp;&amp;p2x&gt;vragi3Objects[i80].v3x-300*lag&amp;&amp;aktivatorp2==1))
&nbsp; &amp;&amp;x2-55&gt;vragi3Objects[i80].v3x&amp;&amp;vragi3Objects[i80].ubit!=1))//просчёт урона
{

//Тут мы оказываемся если кто-то из игроков попал по медведю, но надо ж теперь узнать какой, верно?
if(shot==0)
{
if(((py&lt;vragi3Objects[i80].v3y+200&amp;&amp;py&gt;vragi3Objects[i80].v3y+105&amp;&amp;px&lt;=vragi3Objects[i80].v3x+170&amp;&amp;px&gt;vragi3Objects[i80].v3x-300*lag&amp;&amp;aktivatorp==1)||
&nbsp;&nbsp; (p1d1y&lt;vragi3Objects[i80].v3y+200&amp;&amp;p1d1y&gt;vragi3Objects[i80].v3y+105&amp;&amp;p1d1x&lt;=vragi3Objects[i80].v3x+170&amp;&amp;p1d1x&gt;vragi3Objects[i80].v3x-300*lag&amp;&amp;aktivatorp1d1==1)||
&nbsp;&nbsp; (p1d2y&lt;vragi3Objects[i80].v3y+200&amp;&amp;p1d2y&gt;vragi3Objects[i80].v3y+105&amp;&amp;p1d2x&lt;=vragi3Objects[i80].v3x+170&amp;&amp;p1d2x&gt;vragi3Objects[i80].v3x-300*lag&amp;&amp;aktivatorp1d2==1)||
&nbsp;&nbsp; (p1d3y&lt;vragi3Objects[i80].v3y+200&amp;&amp;p1d3y&gt;vragi3Objects[i80].v3y+105&amp;&amp;p1d3x&lt;=vragi3Objects[i80].v3x+170&amp;&amp;p1d3x&gt;vragi3Objects[i80].v3x-300*lag&amp;&amp;aktivatorp1d3==1)||
&nbsp;&nbsp; (p1d4y&lt;vragi3Objects[i80].v3y+200&amp;&amp;p1d4y&gt;vragi3Objects[i80].v3y+105&amp;&amp;p1d4x&lt;=vragi3Objects[i80].v3x+170&amp;&amp;p1d4x&gt;vragi3Objects[i80].v3x-300*lag&amp;&amp;aktivatorp1d4==1))
&amp;&amp;x-55&gt;vragi3Objects[i80].v3x)&nbsp;&nbsp; &nbsp;
{vragi3Objects[i80].killed_by=1;}//попал игрок 1
if(((p2y&lt;vragi3Objects[i80].v3y+200&amp;&amp;p2y&gt;vragi3Objects[i80].v3y+105&amp;&amp;p2x&lt;=vragi3Objects[i80].v3x+170&amp;&amp;p2x&gt;vragi3Objects[i80].v3x-300*lag&amp;&amp;aktivatorp2==1)||
&nbsp;&nbsp; (p2d1y&lt;vragi3Objects[i80].v3y+200&amp;&amp;p2d1y&gt;vragi3Objects[i80].v3y+105&amp;&amp;p2d1x&lt;=vragi3Objects[i80].v3x+170&amp;&amp;p2d1x&gt;vragi3Objects[i80].v3x-300*lag&amp;&amp;aktivatorp1d1==1)||
&nbsp;&nbsp; (p2d2y&lt;vragi3Objects[i80].v3y+200&amp;&amp;p2d2y&gt;vragi3Objects[i80].v3y+105&amp;&amp;p2d2x&lt;=vragi3Objects[i80].v3x+170&amp;&amp;p2d2x&gt;vragi3Objects[i80].v3x-300*lag&amp;&amp;aktivatorp1d2==1)||
&nbsp;&nbsp; (p2d3y&lt;vragi3Objects[i80].v3y+200&amp;&amp;p2d3y&gt;vragi3Objects[i80].v3y+105&amp;&amp;p2d3x&lt;=vragi3Objects[i80].v3x+170&amp;&amp;p2d3x&gt;vragi3Objects[i80].v3x-300*lag&amp;&amp;aktivatorp1d3==1)||
&nbsp;&nbsp; (p2d4y&lt;vragi3Objects[i80].v3y+200&amp;&amp;p2d4y&gt;vragi3Objects[i80].v3y+105&amp;&amp;p2d4x&lt;=vragi3Objects[i80].v3x+170&amp;&amp;p2d4x&gt;vragi3Objects[i80].v3x-300*lag&amp;&amp;aktivatorp1d4==1))
&nbsp;&amp;&amp;x2-55&gt;vragi3Objects[i80].v3x)
{vragi3Objects[i80].killed_by=2;}//попал игрок 2
//Дальше Вам что-то показывать мне уже страшно...</pre>
      <p>Я думаю, за такой код многие низкоуровневые системные программисты пожали бы руку, а высокоуровневые
        программисты — горло.</p>
      <figure style="width: 96px" class="alignright">
        <img src="./Page_files/ptenec_anime-1.png" alt="Птенец идет - лень было делать долгую анимацию, обошелся тремя кадрами">
        <figcaption class="wp-caption-text">Птенец идет — лень было делать долгую анимацию, обошелся тремя
          кадрами</figcaption>
      </figure>
      <p>Последним добавленным врагом были птенцы. По задумке при убийстве птенца, если его разрывало на мясо,
        экран должен был трястись. Если же его не разрывало, то он должен был вести&nbsp; себя как воздушный
        шарик: все Вы помните по какой траектории летает сдувшийся воздушный шар. Более того, звуки должны
        были быть соответствующими. Но, я так и не доделал птенцов. В нынешнем состоянии они просто выходят на
        свою орбиту и кружатся некоторое время.</p>
      <p>Совсем другое дело, как это выглядит в коде. Я в школе не сильно любил тригонометрию, хоть и дружил с
        ней. Если кто не помнит, движение по окружности радиусом R задается формулами: x=R*cos(a), y=R*sin(a),
        где альфа — текущий угол на окружности. Меняем угол и пересчитываем координаты. Всё! Но нет же, у меня
        был свой подход: движение по окружности делится на 4 фазы (4 четверти круга), в каждой из которых
        происходит какая-то магия (отступы и комментарии сохранены):</p>
      <pre>if(vragi4Objects[i120].polet==1)//polet
{

//летим к радиусу
if(sqrt((vragi4Objects[i120].v4y-vragi4Objects[i120].ry)*(vragi4Objects[i120].v4y-vragi4Objects[i120].ry)+
&nbsp;&nbsp; (vragi4Objects[i120].v4x-vragi4Objects[i120].rx)*(vragi4Objects[i120].v4x-vragi4Objects[i120].rx))&gt;=vragi4Objects[i120].r&amp;&amp;
&nbsp; vragi4Objects[i120].kruzhit==false)
{
vragi4Objects[i120].v4y-=vragi4Objects[i120].speedY*lag;
if(vragi4Objects[i120].v4x&gt;=vragi4Objects[i120].rx)
{vragi4Objects[i120].v4x-=vragi4Objects[i120].speedY*(vragi4Objects[i120].v4x-vragi4Objects[i120].rx)/(vragi4Objects[i120].v4y-vragi4Objects[i120].ry)*lag;}
if(vragi4Objects[i120].v4x&lt;vragi4Objects[i120].rx)
{vragi4Objects[i120].v4x+=vragi4Objects[i120].speedY*(vragi4Objects[i120].rx-vragi4Objects[i120].v4x)/(vragi4Objects[i120].v4y-vragi4Objects[i120].ry)*lag;}



if(sqrt((vragi4Objects[i120].v4y-vragi4Objects[i120].ry)*(vragi4Objects[i120].v4y-vragi4Objects[i120].ry)+
(vragi4Objects[i120].v4x-vragi4Objects[i120].rx)*(vragi4Objects[i120].v4x-vragi4Objects[i120].rx))&lt;=vragi4Objects[i120].r) {vragi4Objects[i120].kruzhit=true; if(vragi4Objects[i120].krug==0) {vragi4Objects[i120].gradus=0; vragi4Objects[i120].gradusNext=M_PI-M_PI_4;} } } //прилетели к радиусу //летим по кругу if(vragi4Objects[i120].kruzhit==true) { if(vragi4Objects[i120].chetvert_n==1) {vragi4Objects[i120].gradus-=M_PI_4/(42+(150/vragi4Objects[i120].r)*(150/vragi4Objects[i120].r))*(150/vragi4Objects[i120].r)*lag;} if(vragi4Objects[i120].chetvert_n==-1) {vragi4Objects[i120].gradus+=M_PI_4/(42+(150/vragi4Objects[i120].r)*(150/vragi4Objects[i120].r))*(150/vragi4Objects[i120].r)*lag;} if(vragi4Objects[i120].zahod==-1)//заходим снизу { if(vragi4Objects[i120].up==true)//летим вверх { //середина if(vragi4Objects[i120].v4y&gt;=(vragi4Objects[i120].ry-vragi4Objects[i120].r/2)&amp;&amp;
&nbsp;&nbsp; vragi4Objects[i120].v4y&lt;=(vragi4Objects[i120].ry+vragi4Objects[i120].r/2))&nbsp;&nbsp; &nbsp;
{vragi4Objects[i120].v4y-=vragi4Objects[i120].speedY*lag;
if(vragi4Objects[i120].chetvert==1)//против часовой (справа)
{vragi4Objects[i120].v4x=sqrt(vragi4Objects[i120].r*vragi4Objects[i120].r-(vragi4Objects[i120].v4y-vragi4Objects[i120].ry)*(vragi4Objects[i120].v4y-vragi4Objects[i120].ry))+vragi4Objects[i120].rx;}
if(vragi4Objects[i120].chetvert==-1)//по часовой (слева)
{vragi4Objects[i120].v4x=vragi4Objects[i120].rx-sqrt(vragi4Objects[i120].r*vragi4Objects[i120].r-(vragi4Objects[i120].v4y-vragi4Objects[i120].ry)*(vragi4Objects[i120].v4y-vragi4Objects[i120].ry));}
}


//по краям
if(vragi4Objects[i120].v4y&lt;=(vragi4Objects[i120].ry-vragi4Objects[i120].r/2)|| &nbsp;&nbsp; vragi4Objects[i120].v4y&gt;=(vragi4Objects[i120].ry+vragi4Objects[i120].r/2))&nbsp;&nbsp; &nbsp;
{
if((vragi4Objects[i120].chetvert==-1&amp;&amp;vragi4Objects[i120].v4y&lt;=(vragi4Objects[i120].ry-vragi4Objects[i120].r/2))|| (vragi4Objects[i120].chetvert==1&amp;&amp;vragi4Objects[i120].v4y&gt;=(vragi4Objects[i120].ry+vragi4Objects[i120].r/2)))
{vragi4Objects[i120].v4x+=vragi4Objects[i120].speedY*lag;}
if((vragi4Objects[i120].chetvert==-1&amp;&amp;vragi4Objects[i120].v4y&gt;=(vragi4Objects[i120].ry+vragi4Objects[i120].r/2))||
(vragi4Objects[i120].chetvert==1&amp;&amp;vragi4Objects[i120].v4y&lt;=(vragi4Objects[i120].ry-vragi4Objects[i120].r/2))) {vragi4Objects[i120].v4x-=vragi4Objects[i120].speedY*lag;} if(vragi4Objects[i120].v4y&gt;=vragi4Objects[i120].ry)
{vragi4Objects[i120].v4y=sqrt(vragi4Objects[i120].r*vragi4Objects[i120].r-(vragi4Objects[i120].v4x-vragi4Objects[i120].rx)*(vragi4Objects[i120].v4x-vragi4Objects[i120].rx))+vragi4Objects[i120].ry;}
if(vragi4Objects[i120].v4y&lt;vragi4Objects[i120].ry)
{vragi4Objects[i120].v4y=vragi4Objects[i120].ry-sqrt(vragi4Objects[i120].r*vragi4Objects[i120].r-(vragi4Objects[i120].v4x-vragi4Objects[i120].rx)*(vragi4Objects[i120].v4x-vragi4Objects[i120].rx));}
}

//смена направления вниз
if(vragi4Objects[i120].v4y&lt;=vragi4Objects[i120].ry-(vragi4Objects[i120].r-1)) {vragi4Objects[i120].up=false; if(vragi4Objects[i120].chetvert_n==1&amp;&amp;vragi4Objects[i120].chetvert==1) {vragi4Objects[i120].chetvert=-1;} if(vragi4Objects[i120].chetvert_n==-1&amp;&amp;vragi4Objects[i120].chetvert==-1) {vragi4Objects[i120].chetvert=1;}}//смена направления вниз }//летим вверх if(vragi4Objects[i120].up==false)//летим вниз { //середина if(vragi4Objects[i120].v4y&gt;=(vragi4Objects[i120].ry-vragi4Objects[i120].r/2)&amp;&amp;
&nbsp;&nbsp; vragi4Objects[i120].v4y&lt;=(vragi4Objects[i120].ry+vragi4Objects[i120].r/2))&nbsp;&nbsp; &nbsp;
{vragi4Objects[i120].v4y+=vragi4Objects[i120].speedY*lag;
if(vragi4Objects[i120].chetvert==1)//против часовой (справа)
{vragi4Objects[i120].v4x=sqrt(vragi4Objects[i120].r*vragi4Objects[i120].r-(vragi4Objects[i120].v4y-vragi4Objects[i120].ry)*(vragi4Objects[i120].v4y-vragi4Objects[i120].ry))+vragi4Objects[i120].rx;}
if(vragi4Objects[i120].chetvert==-1)//по часовой (слева)
{vragi4Objects[i120].v4x=vragi4Objects[i120].rx-sqrt(vragi4Objects[i120].r*vragi4Objects[i120].r-(vragi4Objects[i120].v4y-vragi4Objects[i120].ry)*(vragi4Objects[i120].v4y-vragi4Objects[i120].ry));}
}


//по краям
if(vragi4Objects[i120].v4y&lt;=(vragi4Objects[i120].ry-vragi4Objects[i120].r/2)|| &nbsp;&nbsp; vragi4Objects[i120].v4y&gt;=(vragi4Objects[i120].ry+vragi4Objects[i120].r/2))&nbsp;&nbsp; &nbsp;
{
if((vragi4Objects[i120].chetvert==-1&amp;&amp;vragi4Objects[i120].v4y&lt;=(vragi4Objects[i120].ry-vragi4Objects[i120].r/2))|| (vragi4Objects[i120].chetvert==1&amp;&amp;vragi4Objects[i120].v4y&gt;=(vragi4Objects[i120].ry+vragi4Objects[i120].r/2)))
{vragi4Objects[i120].v4x-=vragi4Objects[i120].speedY*lag;}
if((vragi4Objects[i120].chetvert==-1&amp;&amp;vragi4Objects[i120].v4y&gt;=(vragi4Objects[i120].ry+vragi4Objects[i120].r/2))||
(vragi4Objects[i120].chetvert==1&amp;&amp;vragi4Objects[i120].v4y&lt;=(vragi4Objects[i120].ry-vragi4Objects[i120].r/2))) {vragi4Objects[i120].v4x+=vragi4Objects[i120].speedY*lag;} if(vragi4Objects[i120].v4y&gt;=vragi4Objects[i120].ry)
{vragi4Objects[i120].v4y=sqrt(vragi4Objects[i120].r*vragi4Objects[i120].r-(vragi4Objects[i120].v4x-vragi4Objects[i120].rx)*(vragi4Objects[i120].v4x-vragi4Objects[i120].rx))+vragi4Objects[i120].ry;}
if(vragi4Objects[i120].v4y&lt;vragi4Objects[i120].ry) {vragi4Objects[i120].v4y=vragi4Objects[i120].ry-sqrt(vragi4Objects[i120].r*vragi4Objects[i120].r-(vragi4Objects[i120].v4x-vragi4Objects[i120].rx)*(vragi4Objects[i120].v4x-vragi4Objects[i120].rx));} } //смена направления вверх if(vragi4Objects[i120].v4y&gt;=vragi4Objects[i120].ry+(vragi4Objects[i120].r-1))
{vragi4Objects[i120].up=true;
if(vragi4Objects[i120].chetvert_n==1&amp;&amp;vragi4Objects[i120].chetvert==-1)
{vragi4Objects[i120].chetvert=1;}
if(vragi4Objects[i120].chetvert_n==-1&amp;&amp;vragi4Objects[i120].chetvert==1)
{vragi4Objects[i120].chetvert=-1;}}//смена направления вверх
}//летим вниз

}//заход снизу


if(vragi4Objects[i120].gradus&gt;vragi4Objects[i120].gradusNext)
{vragi4Objects[i120].kruzhit=false;
vragi4Objects[i120].krug++;
if(vragi4Objects[i120].zahod==1)
{vragi4Objects[i120].zahod=-1;}
if(vragi4Objects[i120].zahod==-1)
{vragi4Objects[i120].zahod=1;}
vragi4Objects[i120].rx=hge-&gt;Random_Float(vragi4Objects[i120].rx,vragi4Objects[i120].rx+600);
vragi4Objects[i120].ry=hge-&gt;Random_Float(vragi4Objects[i120].ry-300,vragi4Objects[i120].ry-100);
vragi4Objects[i120].gradus=vragi4Objects[i120].gradusNext;
vragi4Objects[i120].gradusNext+=M_PI-M_PI_4;
vragi4Objects[i120].r=hge-&gt;Random_Int(25,50);
}

if(vragi4Objects[i120].gradus&lt;-vragi4Objects[i120].gradusNext) {vragi4Objects[i120].kruzhit=false; vragi4Objects[i120].krug++; if(vragi4Objects[i120].zahod==1) {vragi4Objects[i120].zahod=-1;} if(vragi4Objects[i120].zahod==-1) {vragi4Objects[i120].zahod=1;} vragi4Objects[i120].rx=hge-&gt;Random_Float(vragi4Objects[i120].rx-600,vragi4Objects[i120].rx);
vragi4Objects[i120].ry=hge-&gt;Random_Float(vragi4Objects[i120].ry+100,vragi4Objects[i120].ry+300);
vragi4Objects[i120].gradus=-vragi4Objects[i120].gradusNext;
vragi4Objects[i120].gradusNext+=-(M_PI-M_PI_4);
vragi4Objects[i120].r=hge-&gt;Random_Int(25,50);
}



}//kruzhim

}//polet</pre>
      <p>Некоторые уже утирают слезы, а мы переходим к мясу.</p>
      <h3>Кровища и мясо</h3>
      <p>Обработка крови и мясо — это вообще отдельная песня. Как я себе ее представлял судя по тому, что я
        увидел в Seal Hunter: при попадании создается специальный объект (эмиттер, или, по-русски излучатель),
        который генерирует кровь и мясо. Брызг крови у меня не вышло — я решил, что это будет сильно лагать,
        поэтому при попадании создавался объект массива krovyakObjects, а по факту — картинка. Картинка
        представляла из себя лужицу рисованной крови, которая растягтивалась из точки попадания по оси X и
        немного по Y, и при этом еще постепенно падала наземь.</p>
      <p>Все звучит просто, но вот код…</p>
      <pre>if(krovyakObjects[i92].faza==1&amp;&amp;(krovyakObjects[i92].y2-krovyakObjects[i92].y1&lt;=25||krovyakObjects[i92].y2&lt;=krovyakObjects[i92].niz)) {krovyakObjects[i92].y2+=1.5f*lag;}//растягивается вниз if(krovyakObjects[i92].faza==1&amp;&amp;(krovyakObjects[i92].y2-krovyakObjects[i92].y1&gt;=25||krovyakObjects[i92].y2&gt;=krovyakObjects[i92].niz))
{krovyakObjects[i92].faza=2;
krovyakObjects[i92].y1+=1.5f*lag;}

if(krovyakObjects[i92].faza==2&amp;&amp;krovyakObjects[i92].y2-krovyakObjects[i92].y1&gt;=12)//долетает вниз
{
krovyakObjects[i92].y1+=1.5f*lag;
if(krovyakObjects[i92].seed==101||krovyakObjects[i92].seed==102||krovyakObjects[i92].seed==103)//вперёд
{krovyakObjects[i92].x2+=hge-&gt;Random_Float(1,1.5f)*lag;}
}</pre>
      <p>Также полет лужи крови сопровождался звуком потока (на самом деле было впечатление, что за кадром
        кто-то ссыт, и чем дальше — тем интенсивнее) — сам звук длится буквально миллисекунды, зато он был
        зациклен и проигрывался чуть ли не в каждом кадре. Пришлось даже ограничивать это явление:</p>
      <pre>if(krovyakObjects[i92].seed==1||krovyakObjects[i92].seed==2||krovyakObjects[i92].seed==3)//чтоб поменьше ссанья
{
if(myaskoSsit!=0)
{myasko_ssit();
myaskoSsit=0;}
if(krovyakObjects[i92].blood_time&gt;=950&amp;&amp;time&lt;=krovyakObjects[i92].blood_time-950)
{myaskoSsit=1;}
if((krovyakObjects[i92].blood_time&lt;950&amp;&amp;perez_akt_milli&lt;=krovyakObjects[i92].blood_time+50)
||(perez_akt!=krovyakObjects[i92].blood_time_sec))
{myaskoSsit=1;}
}</pre>
      <p>Код полета луж крови был настолько запутан, что там затерялся один баг: иногда лужа крови не
        «умирала» и останавливалась на земле, а постоянно росла, причем происходило это так: игрок
        перемещается по уровню, а лужа вытягивается за ним. Выглядело убого, так как текстура при этом
        размазывалась до невозможности, но было крайне интересно. При этом продолжал проигрываться звук
        ссанья, из-за чего это превращалось то ли в хоррор, то ли в комедию.</p>
      <h3>Система RPG</h3>
      <p>Так как конечной Вселенской целью данного проекта было, конечно же, развитие навыков разработки игр и
        построение MMORPG мечты (как и у любых других начинающих школьников-игростроевцев), то в игру было
        решено добавить RPG-мод. Его можно было отключить в любой момент в меню опций игры.</p>
      <figure style="width: 907px" class="aligncenter">
        <img src="./Page_files/Screenshot_2.jpg" alt="Окно повышения уровня">
        <figcaption class="wp-caption-text">Окно повышения уровня</figcaption>
      </figure>
      <p>Что из себя представлял RPG-мод? По сути, просто у врагов со временем росла характеристика «защита» и
        урон от оружия постепенно уменьшался. За убийства давался опыт и с повышением уровня можно было
        вызвать специальное диалоговое окно, которое (надо же, хоть тут!) приостанавливало игру и давало
        немного поразмыслить над выбором. На выбор было 3 базовые характеристики и 2 специальные, в
        зависимости от класса. К базовым характеристикам относились: атака — повышение урона оружия в ответ на
        повышение защиты врагов; скорость — увеличивало скорость перемещения по экрану, особенно это помогало
        при таскании тяжелого вооружения; удача — шанс того, что выпадет хороший бонус вместо плохого
        повышался. Из специальных навыков был реально реализован только один — взрывчатка у разрушителя:
        повышался радиус и урон от гранат.</p>
      <p>Планировалось добавить и навыки (что-то по типу навыков в Героях Меча и Магии), но, хорошо, что дело
        до этого так и не дошло. Об этом напоминает только одинокая надпись «Навыки:» в окне справа.</p>
      <p>Урон при включенном RPG-моде высчитывался по формуле (&lt;урон оружия&gt; +
        (&lt;уровень&gt;/2)*&lt;атака&gt;)*1.2 — &lt;защита&gt;:</p>
      <pre>if(LVL2%2==0)
{vragi1Objects[i3].health-=(damage[N_WEAPON2]+LVL2/2*attack2)*1.2f-vragi1Objects[i3].defence;}
if(LVL2%2==1)
{vragi1Objects[i3].health-=(damage[N_WEAPON2]+(LVL2-1)/2*attack2)*1.2f-vragi1Objects[i3].defence;}</pre>
      <p>При этом множитель 1.2 соответствовал именно зайцу, так как это самый слабый враг. Также
        гарантировался урон хотя бы в 5 пунктов, чтобы зайцы хоть как-то умирали:</p>
      <pre>//гарантированный урон
if(damage[N_WEAPON2]+LVL2/2*attack2-vragi1Objects[i3].defence&lt;5||
damage[N_WEAPON2]+(LVL2-1)/2*attack2-vragi1Objects[i3].defence&lt;5)
{vragi1Objects[i3].health-=5;}</pre>
      <h3>RPG руны</h3>
      <p>Было решено расширить RPG-мод — это не только прокачка персонажа, но и появление «магических» врагов.
        Суть заключалась в том, что в случайные моменты времени ри респауне волков и медведей они появлялись с
        рунами (как поперло то, а!) телепортации, лекаря или иллюзиониста.</p>
      <p>Руна телепортации основывалась на баге — как-то случайно была допущена ошибка в коде перемещения
        волков, и они в случайные моменты времени начинали телепортироваться по оси Y, чем неимоверно
        доставляли хлопот игроку. Мне понравилось, и с помощью небольших художеств и сравнительно небольшого
        куска кода эта возможность стала…возможностью</p>
      <p>Руна иллюзии давала зверю 2 иллюзии, которые не получали урон, но передвигались точно так же, как и
        оригинал. При этом было непонятно, где оригинал, а где нет — приходилось стрелять во всех трех видимых
        зверей, чтобы по отлетающей кровищи/мясу определить, кого надо убивать. Это доставляло хлопот, как и
        было задумано.</p>
      <p>Зверь-лекарь лечил сам себя, по сути это регенерация. На него требовалось в 3 раза больше свинца, чем
        обычно.</p>
      <p>Ниже мы телепортируем медведя, причем разброс позиции по оси Y зависел от того, сколько игроков
        играет в данный момент — чтобы не становилось совсем сложно.</p>
      <pre>while((vragi3Objects[i80].teleporty&gt;vragi3Objects[i80].v3y&amp;&amp;vragi3Objects[i80].teleporty-vragi3Objects[i80].v3y&lt;100)|| &nbsp;&nbsp; &nbsp;&nbsp; (vragi3Objects[i80].v3y&gt;vragi3Objects[i80].teleporty&amp;&amp;vragi3Objects[i80].v3y-vragi3Objects[i80].teleporty&lt;100)) { if(player2_aktive==0) {if(DIFF!=0) {vragi3Objects[i80].teleporty=hge-&gt;Random_Float(250,650);}
if(DIFF==0)
{vragi3Objects[i80].teleporty=hge-&gt;Random_Float(350,550);}}
if(player2_aktive==1)
{if(DIFF!=0)
{vragi3Objects[i80].teleporty=hge-&gt;Random_Float(200,700);}
if(DIFF==0)
{vragi3Objects[i80].teleporty=hge-&gt;Random_Float(300,600);}}
}
</pre>
      <h3>Система классов</h3>
      <p>Система классов была отголоском популярной в то время TeamFortress 2. В игре есть 4 класса, каждый из
        который должен был сильно различаться геймплеем. Мясник должен был агрить на себя врагов и орудовать
        холодным оружием (из которого реализована только одна катана, и та калечная), стрелок должен был уметь
        выстраивать врагов перед собой в ряд и прошивать всех пулями с повышенной убойностью и точностью,
        разрушитель должен был использовать взрывчатку, а инженер, как и TF2, должен был больше полагаться на
        автоматические установки (которые готовились, но так и не были введены в игру).</p>
      <figure style="width: 640px" class="aligncenter">
        <img src="./Page_files/Screenshot_5-1024x610.jpg" alt="Щи симулятор жестокости: Одинокий инженер смотрит в даль">
        <figcaption class="wp-caption-text">Одинокий инженер смотрит в даль</figcaption>
      </figure>
      <p>В целом, как видите, замах неплохой. Из этого, как я уже упоминал, было реализовано меню выбора
        класса, различная внешность персонажей, и то, только для первого игрока, повышение точности у стрелка,
        и повышение урона взрывчаткой у разрушителя. А также приманка для мясника. Не густо. Нечего было так
        распыляться. Может быть было реализовано и что-то еще, но все эти фичи настолько размазаны по коду,
        что уже сложно что-то сказать наверняка. Вот, что я нашел в коде просчета волков (vragi2Objects):</p>
      <pre>//агро мясника
if(class1==1&amp;&amp;primanka1&gt;0&amp;&amp;vragi2Objects[i20].v2x+100&lt;=x-16&amp;&amp;sqrt(((x-16)-vragi2Objects[i20].v2x+100)*((x-16)-vragi2Objects[i20].v2x+100)+
(vragi2Objects[i20].v2y+20-y)*(vragi2Objects[i20].v2y+20-y))&lt;=(60+5*primanka1))
{
if(vragi2Objects[i20].v2y+20&lt;y) {vragi2Objects[i20].v2y+=(0.05f+0.1f*sqrt((float)primanka1))*lag;} if(vragi2Objects[i20].v2y+20&gt;y)
{vragi2Objects[i20].v2y-=(0.05f+0.1f*sqrt((float)primanka1))*lag;}
}</pre>
      <h3>Система бонусов</h3>
      <p>В игре также была система бонусов. По геймплею, кстати, очень неплохая штука. Из врага при смерти мог
        случайно выпасть бонус: шило либо знак вопроса. Шило ускоряло игрока на 10% на некоторое время (не
        помню уже на сколько), а в статус баре на правом краю экрана высвечивалась желтая улитка. Из
        случайного бонуса могло выпасть несколько вариантов: пусто, замедление скорости на 10% (красная улитка
        в статус баре), увеличение зарабатываемого опыта на 25% (желтая ламочка в статус баре) и уменьшение
        получаемого опыта на 50% (красная лампочка). Бонусы могли стаковаться по нескольку штук, но эффект от
        стакования разный.<br>
        Очень интересно все это выглядит в коде:</p>
      <pre>//где-то посередине убийства волка
points1+=200;
opit1+=(70+vragi2Objects[i20].defence*vragi2Objects[i20].defence/LVL1)*w_opit_volk[N_WEAPON1]*(1+0.25f*umnik1)/daun1;</pre>
      <p>Опыт от волка равнялся (70 + его защита в квадрате делить на уровень игрока) * множитель опыта от
        убийства волка для текущего оружия игрока, и все это умножалось на (1+0.25f*umnik1)/daun1. Переменная
        umnik1 отвечала за бонус повышения заработка опыта, и стабтильно увеличивала его на 25% каждый раз, а
        daun1 все время равнялся единице (так как на ноль делить нельзя) и при увеличении сначала отбирал 50%,
        затем 66%, затем 75% и т.д….Так что игра была не настолько жестока как могла быть =).</p>
      <p>Код просчета активации бонусов выглядит так (здесь при включенном RPG-моде работали все бонусы, а при
        выключенном, что не вошло в листинг снизу, только шило). Я еще поправил отступы, чтобы было легче
        отличить просчет одного бонуса от другого, хотя, наверное, зря я это сделал. Нарушил первозданность
        щей. Но все комментарии первозданны.</p>
      <pre>if(RPGMOD==true)
{
switch(bonusiObjects[i29].type)
{
case 0://рандом
bonusiObjects[i29].shans=hge-&gt;Random_Int(1,100);


//+ СКОРОСТЬ
if(bonusiObjects[i29].shans&gt;=1&amp;&amp;bonusiObjects[i29].shans&lt;=20+luck1/2) {bonusi1[N_BONUS1].znachenie=skorost1*0.1f; bonusi1[N_BONUS1].type=1; bonusi1[N_BONUS1].id=i29; speed+=bonusi1[N_BONUS1].znachenie; bonustext1_1(); //появление статуса +10% скорость statusi1[N_BONUSSTATUS1].akt=1; statusi1[N_BONUSSTATUS1].type=1; statusi1[N_BONUSSTATUS1].id=i29; statusi1[N_BONUSSTATUS1].queue=status_queue1; status_queue1++; N_BONUSSTATUS1++; if(N_BONUSSTATUS1&gt;=MAX_BONUSSTATUS-1)
{N_BONUSSTATUS1=0;}

N_BONUS1++;
if(N_BONUS1&gt;=MAX_BONUSI-1)
{N_BONUS1=0;}

}//закрытие про шило


//ДАУНИЗМ
if(bonusiObjects[i29].shans&gt;=21+luck1/2&amp;&amp;bonusiObjects[i29].shans&lt;=40) { daun1++; bonusi1[N_BONUS1].type=2; bonusi1[N_BONUS1].id=i29; bonustext1_2(); //появление статуса даунизма statusi1[N_BONUSSTATUS1].akt=1; statusi1[N_BONUSSTATUS1].type=2; statusi1[N_BONUSSTATUS1].id=i29; statusi1[N_BONUSSTATUS1].queue=status_queue1; status_queue1++; N_BONUSSTATUS1++; if(N_BONUSSTATUS1&gt;=MAX_BONUSSTATUS-1)
{N_BONUSSTATUS1=0;}

N_BONUS1++;
if(N_BONUS1&gt;=MAX_BONUSI-1)
{N_BONUS1=0;}}


//УЛИТКА
if(bonusiObjects[i29].shans&gt;=41&amp;&amp;bonusiObjects[i29].shans&lt;=60-luck1/2) { bonusi1[N_BONUS1].znachenie=skorost1*0.2f; bonusi1[N_BONUS1].type=3; bonusi1[N_BONUS1].id=i29; speed-=bonusi1[N_BONUS1].znachenie; bonustext1_3(); //появление статуса замедления statusi1[N_BONUSSTATUS1].akt=1; statusi1[N_BONUSSTATUS1].type=3; statusi1[N_BONUSSTATUS1].id=i29; statusi1[N_BONUSSTATUS1].queue=status_queue1; status_queue1++; N_BONUSSTATUS1++; if(N_BONUSSTATUS1&gt;=MAX_BONUSSTATUS-1)
{N_BONUSSTATUS1=0;}

N_BONUS1++;
if(N_BONUS1&gt;=MAX_BONUSI-1)
{N_BONUS1=0;}}


//УМНИК
if(bonusiObjects[i29].shans&gt;=61-luck1/2&amp;&amp;bonusiObjects[i29].shans&lt;=80) { umnik1++; bonusi1[N_BONUS1].type=4; bonusi1[N_BONUS1].id=i29; bonustext1_4(); //появление статуса statusi1[N_BONUSSTATUS1].akt=1; statusi1[N_BONUSSTATUS1].type=4; statusi1[N_BONUSSTATUS1].id=i29; statusi1[N_BONUSSTATUS1].queue=status_queue1; status_queue1++; N_BONUSSTATUS1++; if(N_BONUSSTATUS1&gt;=MAX_BONUSSTATUS-1)
{N_BONUSSTATUS1=0;}


N_BONUS1++;
if(N_BONUS1&gt;=MAX_BONUSI-1)
{N_BONUS1=0;}}
//НИЧЕГО
if(bonusiObjects[i29].shans&gt;80)
{bonustext1_0();}

bonusiObjects[i29].akt=0;
bonusiObjects[i29].akt_time=perez_akt;
bonusiObjects[i29].akt_time_milli=GetTime();

break;
case 1://шило в жопу

bonusi1[N_BONUS1].znachenie=skorost1*0.1f;
bonusi1[N_BONUS1].type=1;
bonusi1[N_BONUS1].id=i29;
speed+=bonusi1[N_BONUS1].znachenie;
bonustext1_1();

//появление статуса +10% скорость
statusi1[N_BONUSSTATUS1].akt=1;
statusi1[N_BONUSSTATUS1].type=1;
statusi1[N_BONUSSTATUS1].id=i29;
statusi1[N_BONUSSTATUS1].queue=status_queue1;
status_queue1++;
N_BONUSSTATUS1++;
if(N_BONUSSTATUS1&gt;=MAX_BONUSSTATUS-1)
{N_BONUSSTATUS1=0;}


N_BONUS1++;
if(N_BONUS1&gt;=MAX_BONUSI-1)
{N_BONUS1=0;}

bonusiObjects[i29].akt=0;
bonusiObjects[i29].akt_time=perez_akt;
bonusiObjects[i29].akt_time_milli=GetTime();

break;}

}//RPGMOD==true</pre>
      <p>Также для новичков покажется интересной реализация вращения изображения бонуса. Так как движок
        двухмерный, а сильно хотелось, чтобы бонусы красиво медленно вращались при выпадении, было придумано
        вот что. Имелась функция рендера спрайта (картинки) по четырем координатам — пара x,y верхнего левого
        угла и пара x,y нижнего правого угла. По сути эта функция растягивает картинку до нужных размеров.
        Когда выпадал бонус, то просто во второй паре координат x постепенно уменьшался, что в итоге приводило
        к тому, что абсцисса правого нижнего угла становилась меньше левого, т.е. они как бы менялись местами.
        В итоге картинка рендерилась «наизнанку», будто произошло вращение на 180 градусов. Затем абсцисса
        уменьшалась до определенного предела и запускался обратный процесс — она увеличивалась. Так как
        изменение абсциссы происходило постепенно, то это действительно выглядело как вращение.</p>
      <h3>Игровой уровень</h3>
      <p>Игровой уровень состоит из трех частей — стартовый экран с поляной, затем, если пройти далее
        появляются пни, затем трава темнеет и где-то с 40% уровня начинается лес из небольшого количества
        случайно расставленных деревьев. Также сразу после стартового экрана на поляне лежит алкаш — просто
        хотелось немного разбавить уровень. На середине уровня стоит ободряющий указатель «еще столько же».
      </p>
      <figure style="width: 150px" class="alignright">
        <img src="./Page_files/alkash1.png" alt="alkash1 - их тоже планировалось несметное множество">
        <figcaption class="wp-caption-text">alkash1 — их тоже планировалось несметное множество</figcaption>
      </figure>
      <p>Для объектов типа пень, знак и дерево был создан отдельный массив, а врагам пришлось немного
        подкрутить мозги, чтобы они эти препятствия аккуратно оббегали. По сути я проверяю близко ли к врагу
        находится объект по оси Х, и, если да, то меняю добавляю небольшую скорость по Y. После того как
        препятствие пройдено по противоположому принципу добавляю скорость по Y, и враг возвращается на свой
        прежний путь.</p>
      <p>Конец уровня обозначивается черно-желтой полосой, после которой идет черная пугающая пустота —
        отсутствие какой-либо текстуры. Не знаю почему, но даже и в голову тогда не пришло, что надо этот
        пробел чем-то заполнить. Уровень есть — и черт с ним!</p>
      <p>Вообще проходится уровень довольно тяжело, но об этом поподробнее ниже в разделе «Геймплей».</p>
      <h1>Дополнительные детали и конец проекта</h1>
      <h3>Главное меню</h3>
      <p>Мне всегда ненравилось денлать менюшки для игр. Даже сейчас, разрабатывая проекты на Unity, с
        адаптивностью и внешним видом разных меню одни проблемы. Что уж говорить про динамическое создание
        меню в коде. В HGE оно было сделано вполне неплохо, насколько это возможно. Но я пошел своим путем.
        Никакой структуры, просто бешеное дерево условий. Не привожу здесь код, так как Вы, наверное, уже
        устали.</p>
      <h3>Поправка FPS</h3>
      <p>В игре был установлен фиксированный FPS в 100 кадров в секунду, но из-за нагрузки мясом и кровью,
        данный показатель сильно проседал, иногда вплоть до нескольких кадров. При этом игра замедлялась, все
        начинал лагать, всевозможные таймеры перезарядки и респауна врагов переставали работать, из-за чего то
        невозможно было выстрелить, то перезарядиться, то враги пропадали…Потом я наткнулся на статью, что,
        оказывается, нужно все переменные, отвечающие за скорость игровых процессов, умножать на коэффициент
        поправки. В идеале, конечно, это должно было быть текущее значение FPS. Но, умножение на FPS почему-то
        давало приемлемый результат только при небольших лагах, поэтому было решено опытным путем вывести свой
        собственный коэффициент.</p>
      <p>Итак, путем экспериментов была выведена данная формула, которая, к слову, сравнительно неплохо
        справлялась со своей задачей:</p>
      <pre>float lag=((1+dt*12)*sqrt(dt/0.006f));
float lag_p=((1+dt*10)*sqrt(dt/0.01f))*((x+1200)/2400);

//чтоб игрок1 тормозил и не улетал за экран
dx*=tormoz; dy*=tormoz;
float lag_igrokam=((1+12*dt)/(1+5*dt))*sqrt(sqrt(sqrt(140/(float)fps)));</pre>
      <p>Ох, я забыл. Формулы было всего аж три штуки! Первая формула (<em>lag</em>) рассчитана на все, кроме
        пуль и перемещений игроков. Вторая,<em>lag_p</em>, применялась для ускорения или замедления пули, ну а
        последняя, самая простая — для перемещения игроков. Здесь dt — это 1/fps, обычно это значение вроде
        0.001-0.015, но при сильных лагах оно подскакивало до десятых долей и намного ускоряло передвижение
        игровых сущностей. Таким образом, игра как бы лагала, но за один длинный кадр, например, то же игрок,
        телепортировался на приличное расстояние.</p>
      <h3>Алгоритм художника</h3>
      <p>Вообще-то в движке HGE присутствует <a
          href="https://ru.wikipedia.org/wiki/Z-%D0%B1%D1%83%D1%84%D0%B5%D1%80%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F"
          target="_blank" rel="nofollow noopener">z-buffer</a>, и таким образом, можно было придавать спрайтам
        различное значение z-index. Однако, в то время я не знал основ компьютерной графики, и, что такое
        z-index в частности. Однако, интуитивно я догадался до алгоритма художника, и реализовал его…не самым
        лучшим образом.</p>
      <p>Так выглядит тасовка элементов массива внутри:</p>
      <pre>for(int ii8=0;ii8&lt;=N_MYASO;ii8++)
{
if(myasko[ii8].akt==1)
{Y[N_Y].type=3;
Y[N_Y].y=myasko[ii8].niz-15;
Y[N_Y].id=ii8;
N_Y++;}
}

for(int ii9=0;ii9&lt;=N_UHI;ii9++)
{
Y[N_Y].type=4;
Y[N_Y].y=uhiObjects[ii9].niz-15;
Y[N_Y].id=ii9;
N_Y++;
}</pre>
      <p>А вот здесь вывод на экран, на экран выводились объекты с определенным id в порядке, в которм они
        присутствовали в массиве A.</p>
      <pre>for(int I=0;I&lt;=N_Y;I++) { ... switch(myasko[A[I].id].seed) {case 1:krovyak_myaso1-&gt;RenderEx(myasko[A[I].id].x1+Xz,myasko[A[I].id].y1,myasko[A[I].id].gradus,myasko[A[I].id].scaleX,0);</pre>
      <h3>Загрузка ресурсов</h3>
      <p>Загрузка ресурсов — это одно из любимейших мест публики, после того как я опубликовал свой исходный
        код. Просто полюбуйтесь на это:</p>
      <pre>if(!menu_font||!oboima_text||!info||!infoR||!infoD||!infoBR||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!oblaka1_tex||!fon1_tex||!fon2_tex||!fon3_tex||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!galka_tex||!galka_menu_tex||!strelka_menu_tex||!strelka_menu_D_tex||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!znak_myasnik_tex||!znak_strelok_tex||!znak_razrushitel_tex||!znak_tehnik_tex||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!status_opit_tex||!status_udar_tex||!status_status_tex||!opit_okno_vibora_tex||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!okno_lvl_progress_tex||!okno_lvl_progress_red_tex||!okno_lvl_progress_green_tex||!okno_lvl_polzunok_tex||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!snd||!ak_reload1||!ak_reload2||!pm_fire||!pm_reload1||!pm_reload2||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!pp19_fire||!pp19_reload1||!pp19_reload2||!fn_f2000_fire||!tt_fire||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!mac_fire||!mac_reload1||!mac_reload2||!webley_fire||!webley_reload1||!webley_reload2||!milkor_fire||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!fn_five_seven_fire||!winch_fire||!drob_reload1||!drob_pompa||!vzriv_grena1||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!rocket_fire||!rocket2_fire||!rocket_polet||!rocket2_polet||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!myaso_upalo1||!myaso_upalo2||!myaso_upalo3||!myaso_upalo4||!myaso_upalo5||!myaso_upalo6||!myaso_upalo7||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!myaso_upalo8||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!myaso_razriv_user1||!myaso_razriv_user2||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!menu_sound||!menu_choose||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!shot1||!headshot1||!headshot2||!headshot3||!headshot4||!headshot5||!headshot6||!headshot7||!headshot8||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!ssik1||!ssik2||!ssik3|!ssik4||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!ptenec_death1||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!ak||!ak2||!ak_upgraded||!ak2_upgraded||!w_pm_tex||!w_pp19_vityaz_tex||!w_fn_f2000_tex||!w_fn_f2000_upgraded_tex||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!w_tt_tex||!w_rpk_tex||!w_mac_tex||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!w_winchester_tex||!w_winchester_anime_tex||!w_rpk47_tex||!w_glok_tex||!w_glok2_tex||!w_rgd5_tex||!w_milkor_tex||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!w_panzer_tex||!w_panzer_out_tex||!w_webley_tex||!w_fn_five_seven_tex||!w_granata_podstvol_tex||!w_granata_panzer_tex||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!w_qlz87_pushka_tex||!w_qlz87_trenoga_tex||!katana_udar_sleva_tex||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!blood1_tex||!blood2_tex||!blood3_tex||!blood_shot1_tex||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!blood_plyam1_tex||!blood_plyam2_tex||!blood_plyam3_tex||!blood_luzha1_tex||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!blood_myaso1_tex||!blood_myaso2_tex||!blood_myaso3_tex||!blood_myaso4_tex||!blood_myaso5_tex||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!blood_zayac_noga1_tex||!blood_zayac_noga2_tex||!blood_zayac_noga3_tex||!blood_zayac_noga4_tex||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!blood_zayac_rebra1_tex||!blood_zayac_rebra2_tex||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!blood_vzriv1_a_tex||!blood_vzriv1_b_tex||!blood_vzriv1_c_tex||!blood_vzriv1_d_tex||!blood_vzriv1_e_tex||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!blood_vzriv1_e2_tex||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!player1_myasnik_gogranata_ruka1_tex||!player1_myasnik_gogranata_ruka2_tex||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!player1_strelok_gogranata_ruka1_tex||!player1_strelok_gogranata_ruka2_tex||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!player1_razrushitel_gogranata_ruka1_tex||!player1_razrushitel_gogranata_ruka2_tex||&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!player1_tehnik_gogranata_ruka1_tex||!player1_tehnik_gogranata_ruka2_tex||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!player1_myasnik_tex||!player1_strelok_tex||!player1_razrushitel_tex||!player1_tehnik_tex||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!player1_myasnik_ruka1_udar_sleva_tex||!player1_strelok_ruka1_udar_sleva_tex||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!player1_razrushitel_ruka1_udar_sleva_tex||!player1_tehnik_ruka1_udar_sleva_tex||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!player1_myasnik_ruka1_pistol_tex||!player1_strelok_ruka1_pistol_tex||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!player1_razrushitel_ruka1_pistol_tex||!player1_tehnik_ruka1_pistol_tex||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!player1_myasnik_ruka1_vintovka_tex||!player1_strelok_ruka1_vintovka_tex||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!player1_razrushitel_ruka1_vintovka_tex||!player1_tehnik_ruka1_vintovka_tex||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!player1_myasnik_ruka1_winch_tex||!player1_strelok_ruka1_winch_tex||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!player1_razrushitel_ruka1_winch_tex||!player1_tehnik_ruka1_winch_tex||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!player2_strelok_tex||!player2_gogranata_ruka1_tex||!player2_gogranata_ruka2_tex||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!player2_strelok_ruka1_udar_sleva_tex||!player2_strelok_ruka1_vintovka_tex||!player2_strelok_ruka1_pistol_tex||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!zayac_go_tex||!zayac_uhi_k_tex||!zayac_uhi_s_tex||!zayac_uhi_tex||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!zayac_boshka_tex||!zayac_boshka_bezuh_tex||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!volk_go_tex||!volk_trup1_a_tex||!volk_trup1_b_tex||!volk_trup1_c_tex||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!medved_go_tex||!medved_boshka1_tex||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!medved_trup1_a_tex||!medved_trup1_b_tex||!medved_trup1_c_tex||!medved_trup1_d_tex||!medved_trup1_e_tex||!medved_trup1_f_tex||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!medved_trup1_a_bezboshki_tex||!medved_trup1_b_bezboshki_tex||!medved_trup1_c_bezboshki_tex||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!medved_trup1_d_bezboshki_tex||!medved_trup1_e_bezboshki_tex||!medved_trup1_f_bezboshki_tex||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!ptenec_go_tex||!ptenec_wait_tex||!ptenec_vpolete_tex||!ptenec_vpolete_reverse_tex||!ptenec_trup1_tex||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!ptenec_boshka_vzriv1_a_tex||!ptenec_boshka_vzriv1_b_tex||!ptenec_boshka_vzriv1_c_tex||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!ptenec_boshka_vzriv1_d_tex||!ptenec_boshka_vzriv1_e_tex||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!RPG_healer_tex||!RPG_illusionist_tex||!RPG_teleporter_tex||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!bonus_shilo_tex||!bonus_this_tex||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!bonus_shilo_text_tex||!bonus_this_text_tex||!bonus_daun_text_tex||!bonus_ulitka_text_tex||!bonus_umnik_text_tex||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!bonus_shilo_status_tex||!bonus_daun_status_tex||!bonus_ulitka_status_tex||!bonus_umnik_status_tex||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!zayac_trup1_a_tex||!zayac_trup1_b_tex||!zayac_trup1_c_tex||!zayac_trup1_d_tex||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!zayac_trup1_a_bezuh_tex||!zayac_trup1_b_bezuh_tex||!zayac_trup1_c_bezuh_tex||!zayac_trup1_d_bezuh_tex||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!zayac_trup1_a_bezboshki_tex||!zayac_trup1_b_bezboshki_tex||!zayac_trup1_c_bezboshki_tex||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!zayac_trup1_d_bezboshki_tex||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!zayac_go_bezuh_tex||!ogon1||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!blood_ssit_tex||!RPG_healing_tex||!vzriv_grena_tex||!vzriv_ogon_grena_tex||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!alkash1_tex||!derevo1_tex||!penek1_tex||
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!znak_polputi_tex||!polosa_finish_tex)
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// If one of the data files is not found, display
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// an error message and shutdown.
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;MessageBox(NULL, "Ошибка загрузки игровых файлов.", "Ошибка, пля!!!", MB_OK | MB_ICONERROR | MB_APPLMODAL);
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;hge-&gt;System_Shutdown();
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;hge-&gt;Release();
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return 0;
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}</pre>
      <p>Данное условие проверки загрузки всех ресурсов без исключения было даже <a href="http://govnokod.ru/9903"
          target="_blank" rel="nofollow noopener">опубликовано на говнокоде</a>. Жалко только, что условие так и не
        поместилось целиком — ограничение сайта =(. Зато это был лучший говнокод апреля 2012 года! Можно даже
        было при запуске игры поставить бейджик в главном меню, как это сделано в том же WoT (лучшая игра КРИ,
        лучший говнокод месяца и т.д.).</p>
      <p>Еще веселее было наблюдать комментарии людей, утверждающих, что этот код был сгенерирован каким-то
        препроцессором (не могу уже найти ссылку). Положа сердце на руку скажу — никакого препроцессора,
        только хардкор, только ручная работа!</p>
      <p>Названия переменных продиктованы здравым смыслом (о как!), например
        <em>medved_trup1_a_bezboshki_tex</em> и <em>medved_trup1_b_bezboshki_tex</em> это просто два
        последовательных кадра (a и b) первой вариации анимации падения медведя без бошки. Предполагалось, что
        анимаций будет больше, я везде оставлял простор для творчества, но, увы, анимации отбирали кучу
        времени, так как я не художник, и приходилось делать все одному. Хотя нет, с анимашками мне немного
        помог друг (тоже не профессионал).
      </p>
      <h3>Номенклатура переменных</h3>
      <p>Сквозь всю программу виднеется еще один недостаток: имена переменных как на русском (транслите), так
        и на английском языке. Причем все это вкупе составляет дикую смесь. Ниже представлено объявление
        звуковых спецэффектов для падающего мяса, попаданий в голову врагам и брызг крови. Озвучка взята
        частью из Seal Hunter, частью из самодельной озвучки для него же.</p>
      <pre>HEFFECT myaso_upalo1;
HEFFECT myaso_upalo2;
HEFFECT myaso_upalo3;
HEFFECT myaso_upalo4;
HEFFECT myaso_upalo5;
HEFFECT myaso_upalo6;
HEFFECT myaso_upalo7;
HEFFECT myaso_upalo8;

HEFFECT myaso_razriv_user1;//здесь user - не юзер, а усёр
HEFFECT myaso_razriv_user2;

HEFFECT shot1;//а далее нормальный английский
HEFFECT headshot1;
HEFFECT headshot2;
HEFFECT headshot3;
HEFFECT headshot4;
HEFFECT headshot5;
HEFFECT headshot6;
HEFFECT headshot7;
HEFFECT headshot8;

HEFFECT ssik1;//опять транслит: ссык
HEFFECT ssik2;
HEFFECT ssik3;
HEFFECT ssik4;</pre>
      <p>Как видите, какого-то общего стандарта нет. Переменные называются то на нормальном английском, то на
        тарабарщине, что, несомненно, является минусом. Хотя, возможно, для начинающих это и не критично, но,
        честно, более-менее профессионалов от такого коробит. Если бы даже у игры присутствовала какая-нибудь
        нормальная архитектура, и игру можно было бы выложить на GitHub, чтобы ее кто-то дальше развивал, то
        этот «кто-то» явно должен знать русский язык. А это сильно сужает аудиторию разработчиков, способных
        «подхватить» Ваш проект. В общем, не делайте так.</p>
      <p>Также у меня была паранойя по поводу переменных-счетчиков циклов. Я почему-то подумал, что они
        глобальные, и чтобы случайно не было конфликта начал нумеровать их: <em>i, i1, i2, i3</em>…Где-то на
        сто-каком-то цикле я сбился со счету и начал писать переменные <em>ii1, ii2, ii3</em>, чтобы
        наверняка. Потом пошли <em>iii1,iii2</em>… До <em>iiii</em> дело, к счастью, не дошло.</p>
      <h3>Комментарии</h3>
      <p>Иногда было лень стирать старые неактуальные комментарии, из-за чего происходило нечто подобное:</p>
      <pre>N_BLOOD++;

if(N_BLOOD==MAX_BLOOD-1)
{
NUMBER_BLOOD=N_BLOOD;&nbsp;&nbsp; &nbsp;
N_BLOOD=0;
peregruzheno_blood=1;}//&nbsp; ААААА ФАК МОЙ МОСК ТУТ ВСЕГДА ДОЛЖЕН БЫТЬ 0!!!!!

krovyakObjects[N_BLOOD].seed=hge-&gt;Random_Int(101,103);

</pre>
      <h3>Процесс отладки</h3>
      <p>На самом деле весь секрет какой-никакой работоспособности игры состоит в сути процесса ее отладки.
        Конечно же, я тогда еще не умел толком пользоваться дебаггером, хотя подстмотреть значения переменных
        мог. Секрет вот в чем: после непродолжительного написания кода (примерно 50-100 строк) следовала
        немедленная параноидальная отладка игры в стиле «А вдруг что-то сломалось?» путем ее запуска и,
        собственно, игры в игру. Причем если код писался, скажем, полчаса, то игра проверялась после этого
        где-то час-полтора. Иногда и дольше, если я заигрывался. Проверялось все путем прохождения уровня. При
        этом обязательно надо было чтобы кого-то разорвало, чтобы выбежали все доступные враги и т.д…Вдруг че?
      </p>
      <blockquote>
        <p>Таким образом я заимел вредную привычку писать код мелкими кусками и сразу его проверять, от
          которой я избавился довольно-таки недавно, примерно года полтора-два назад. Я назвал это «синдром
          щей».</p>
      </blockquote>
      <p>Крайне неприятная штука, основанная на неуверенности в себе и своем коде, которая затягивает
        разработку как минимум раза в два. Возможно, я сейчас где-то неправ, и для новичка оно было полезно,
        ведь количество ошибок на тысячу строк кода намного выше, чем у опытных прогеров. Но далее было
        реально неудобно работать с таким синдромом.</p>
      <p>Кстати, как сейчас помню, я где-то к середине разработки «Щей» (года через пол) нашел функцию «Поиск
        и замена». Вроде бы я должен был быть в восторге, но я отчетливо понимал, что это всего-лишь замена
        текста, которая может привести к замене части имени какой-нибудь переменной. Поэтому пользовался этой
        функцией редко, а менял все значения руками. Так моей душе было спокойнее. Я чувствовал, что код не
        простой, и лучше «держать ситуацию в руках». Это паранойя, доктор?</p>
      <h3>Все хорошо</h3>
      <p>Я долгое время так и думал. В Интернете для начинающих разработчиков игр написана куча статей в духе
        «<a href="http://www.gamedev.ru/gamedesign/articles/design_mmorpg" target="_blank"
          rel="nofollow noopener">делать игры нереально сложно, это удел немногих</a>«,
        поэтому, столкнувшись с описанными выше трудностями, я ничего и не заподозрил. Нет, конечно, игры
        делать сложно, по сравнению с обычным среднестатистическим программным обеспечением, но не настолько
        же!</p>
      <p>В общем по ходу разработки, когда иной раз за день код вырастал на пару-тройку тысяч строк, я
        чувствовал неподдельную гордость за себя. Более двадцати тысяч строк кода! В одном файле! Сложно, но я
        не сдавался. Я был крут!</p>
      <p>Все было в этом духе, пока я не нашел, что такое рефакторинг…</p>
      <h3>Рефакторинг и конец проекта</h3>
      <p>Собственно, кто не знает, рефакторинг — это оптимизация кода с целью улучшить его гибкость и
        поддерживаемость. Функционал при этом должен сохраниться. Поначалу, конечно, все ломается, но потом
        все должно стать на круги своя.</p>
      <p>Так вот, столкнувшись с описание такого явления, я подумал — а почему бы и мне не попробовать? У меня
        на тот момент было 25000 строк отборного кода в одном файле. Про разбиение на файлы я даже и не думал
        — «та еще морока, зачем?», а вот сделать, например, добавление нового оружия удобнее и быстрее —
        запросто. В общем, я начал рефакторить код, вынес все параметры оружия в глобальные массивы,
        определение которых поставил в начале файла, чтобы было удобно. В общем, поработал на славу:</p>
      <pre>//св-ва оружий. формат: АК,ПМ,ПП-19'Витязь',FN_F2000,TT,РПК,MAC,WINCHESTER,РПК47,ГЛОК,РГД-5,катана,MILKOR-MGL,
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;//&nbsp;&nbsp; 0&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp; 5&nbsp;&nbsp; 6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp; 9&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; 10&nbsp;&nbsp;&nbsp;&nbsp; 11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 12&nbsp;&nbsp;&nbsp; &nbsp;
//Panzerfaust3, Webley mk4, FN Five-Seven
//&nbsp;&nbsp;&nbsp;&nbsp; 13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 15
int oboim[16]={30,8,30,30,8,45,50,8,75,17,1,0,6,1,6,20};
int oboim2[16]={30,8,30,30,8,45,50,8,75,17,1,0,6,1,6,20};
int oboima_alt[16]={1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0};
int oboima2_alt[16]={1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0};
int damage[16]={70,20,40,55,30,72,35,75,72,20,300,20,270,550,50,32};
float weight[16]={3,0.4f,2.2f,3.6f,0.5f,4.5f,2,3.2f,4.8f,0.7f,0.2f,0.5f,5.3f,8,0.7f,0.5f};
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ак пм&nbsp; пп19 ф2000&nbsp; ТТ&nbsp;&nbsp; рпк&nbsp;&nbsp; мас&nbsp; winch рпк47&nbsp; глок ргд-5 катана MILKOR-MGL P3 Wmk4&nbsp; FN5-7
int cena[16]={15000,0,7500,27500,1000,24000,5000,7500,22000,1500,3500,3000,20000,40000,2000,3000};
int cena_up[2]={12500,9000};
int reload_time[16]={2,1,1,2,1,3,1,0,3,1,0,0,0,3,1,1};
int reload_time_milli[16]={0,0,500,0,0,0,500,0,0,0,0,500,0,0,0,0};
float weapon_x1[16];
float weapon_y1[16];
float weapon_x2[16];
float weapon_y2[16];
float weapon2_x1[16];
float weapon2_y1[16];
float weapon2_x2[16];
float weapon2_y2[16];
float w_x1[16]={-55,-32,-46,-60,-35,-72,-30,-72,-73,-35,0,0,-60,-70,-40,-35};
float w_y1[16]={-15,-12,-15,-22,-13,-15,-15,-15,-15,-13,0,0,-20,-21,-16,-14};
float w_x2[16]={&nbsp; 8, -7,&nbsp; 7,&nbsp; 4, -7, 10,&nbsp; 3, 14,&nbsp; 9, -7,0,0, 10, 30, -8, -7};
float w_y2[16]={ 10,&nbsp; 8, 13,&nbsp; 6,&nbsp; 8, 12, 15,&nbsp; 9, 25,&nbsp; 8,0,0,&nbsp; 4,&nbsp; 4,&nbsp; 2,&nbsp; 5};


int radius_vzriva[4]={0,200,200,350};
int damage_gren[4]={0,300,270,500};

int random_rasst_min[16]={400,200,300,450,250,400,300,0,350,250,0,0,0,0,350,350};
int random_rasst_max[16]={600,400,500,650,500,500,450,0,450,400,0,0,0,0,500,500};
float random_value1[16]={5,6,5,3,5.5f,5.5f,5.5f,0,6,6,0,0,0,0,6,4};
float random_value2[16]={9,12,10,6,11,9,12,0,10,11.5f,0,0,0,0,12,10};

float w_opit_zayac[16]={1.2f,2,1.4f,0.8f,1.8f,1,1.6f,1.2f,1,2,1.5f,1.6f,1,0.8f,1.4f,1.2f};
float w_opit_zayac_vschiii[16]={1.2f,2,1.4f,0.8f,1.8f,1,1.6f,1,1,2,1.5f,1.6f,1,1,1.2f,1.4f};
float w_opit_volk[16]={1.2f,2,1.4f,0.8f,1.8f,1,1.6f,1,1,2,1.5f,1.8f,1.2f,1,1.5f,1.5f};
float w_opit_medved[16]={1.2f,2,1.4f,0.8f,1.8f,1,1.6f,1,1,2,1.8f,2,1.4f,1,1.8f,1.6f};</pre>
      <p>Как видите, стало намного удобнее…Или нет?</p>
      <p>Но вот, что меня поразило — за пару часов код уменьшился с 25000 до 20000 строк! При той же
        функциональности! Ничего не поменялось в игре! Совсем! И тут я понял, что что-то с проектом не так.
        Собственно, насколько я помню, этот рефакторинг и был концом проекта. Я тянул этот проект полтора
        года, вплоть до окончания школы, и понял, что дальше разработка невозможна — мотивация была на исходе,
        меня тянула вперед только гордость за себя и поддержка друзей (играть в игру с багами и выискивать их
        было очень фаново). И тут до меня доходит, что все что я написал — говнокод. Так что плодами
        рефакторинга, к сожалению, я практически так и не воспользовался.</p>
      <h1>Что получилось в итоге?</h1>
      <h3>Геймплей игры</h3>
      <p>Геймплей игры получился отменным. Отменно отстойным. Это дичайший хардкор, который&nbsp; еще как-то
        проходил во время разработки (еще бы, я по сути задротил в свою игру, пока дебажил ее каждый раз).</p>
      <p>Начнем хотя бы с того, что при нажатии на кнопку покупки открывалось меню, но игра не
        приостанавливалась! Эта очевидная недоработка была исправлена в ЩИ2, о которой речь пойдет в другой
        раз.</p>
      <p>Далее. Монстры…Кхм, ладно, звери — они быстро становились неубиваемыми, если не прокачивать атаку в
        RPG-режиме игры. К тому же пули иногда пролетали насквозь и не наносили урона.</p>
      <p>Вообще суть заключалась в том, что в игре присутствует 3 режима — зеленый, синий и красный. Они
        сменяли друг друга раз в минуту или две в таком порядке: синий-красный-синий-зеленый-синий-красный и
        т.д. Различались режимы натиском зверей. Подразумевалось, что в зеленом режиме нужно идти вперед,
        «тащя» экран по уровню, таким образом проходя игровой уровень до конца. В синем режиме сделать это
        было очень сложно, а в красном — нереально. И врагов больше, и их скорость выше, и разброс по
        координате Y тоже, по-моему, был больше. Как видите, идея для геймплея основательная, но реализация
        «так себе».</p>
      <p>Ну и самое главное. Недавно сели поиграть в нее с друзьями. Прошли до середины уровня. Кое-как. В
        итоге все начало лагать, так как по уровню раскидано множество мяса, и в свою должность вступили
        вышеприведенные формулы просчета и поправки лагов: при движении по краю экрана вперед нас откатывало
        инерцией назад, при движении назад, от края экрана нас откатывало вперед. Все. Конец. Мы не смогли
        тронуться с места!</p>
      <h3>Реакция общественности</h3>
      <p>*здесь о реакции общественности расскажет Ризитас*</p>
      <h1>Нарушенные принципы программирования</h1>
      <h3>Принцип YAGNI</h3>
      <p>Принцип YAGNI гласит «You Are not Going to Need It», что в переводе означает «Вам это не
        понадобится». Если что-то нужно в данный момент, например мы добавляем новый тип оружия — добавляем
        новый тип оружия, а не закладываем основу для целой классификации. Игра изобилует неиспользованными
        возможностями, которые, по сути, особо и не нужны.</p>
      <pre>Например, вот коды изображений трупов и их частей, а также предметов в игровом уровне:
hgeSprite* krovyak_vzriv1; //посреди вот таких вот объявлений кроется документация
/*ТИПЫ ТРУПОВ
1-ЗАЯЦ 1
2-УШИ(АНИМЕ)
3-УШИ(СПРАЙТ)
300-ВСПЛЕСК ОТ ВЗРЫВА1
301-ВСПЛЕСК ОТ ВЗРЫВА1/2
330-ВСПЛЕСК БОШКИ ПТЕНЦА1
400-КРОВЯК1
401-КРОВЯК2
402-КРОВЯК3
500-МЯСО1
501-МЯСО2
502-МЯСО3
503-МЯСО4
504-МЯСО5
505-ЗАЯЧЬИ РЕБРА1
506-ЗАЯЧЬИ РЕБРА2
507-ЗАЯЧЬЯ НОГА1
508-ЗАЯЧЬЯ НОГА2
509-ЗАЯЧЬЯ НОГА3
510-ЗАЯЧЬЯ НОГА4
511-МЕДВЕЖЬЯ БОШКА1
6-БОШКА
7-БОШКА БЕЗ УШЕЙ
800-ПЛЯМ 1
801-ПЛЯМ 2
802-ПЛЯМ 3
9-ЛУЖА 1 
10-ВОЛК 1
20-МЕДВЕД 1
30-ПТЕНЕЦ 1
31-ЛЕТУЧИЙ ПТЕНЕЦ=)

ТИПЫ БОНУСОВ
0-ВОПРОС
1-ШИЛО
*/</pre>
      <p>Как видите, коды красноречиво говорят, насколько я замахнулся на разнообразие. Я хотел нарисовать не
        менее ста вариаций мяса, всплесков крови, оторванных ушей, голов и тому подобного. Это, конечно, не
        самое страшное из того, что нарушает принцип YAGNI, но, я думаю, суть ясна: тратятся усилия на вещи,
        которые может быть, когда-то, понадобятся. Если бы у меня был художник…</p>
      <h3>Принцип NIH</h3>
      <p>Принцип Not Invented Here. Очень заразная болезнь начинающих программистов, граничащая с паранойей.
        Суть болезни в том, что программист не переносит на дух готовые решения и библиотеки, а каждый раз
        «создает велосипеды» самостоятельно. В лучшем случае будет потрачена только уйма времени. В худшем —
        велосипед не заработает так, как это делает готовая библиотека.</p>
      <p>В игре я использовал HGE, как основу для отрисовки графики, но всю физику реализовывал сам. Если бы я
        взял готовый движок физики, разработка была бы намного приятнее и быстрее. Другое дело, что мне,
        возможно, пришлось бы пользоваться ООП, ведь библиотека диктует свой стиль использования кода, а это
        было в то время очень непонятно и неприятно. Да и разбираться в чужих API я только-только учился. В
        итоге моя лень разобраться в этом породила еще больше работы.</p>
      <h3>Принцип KISS</h3>
      <p>Принцип KISS гласит «Keep It Simple Stupid!». Чем проще концепция или сама система для понимания, тем
        лучше. Как видите, в данном случае простота хуже воровства. Ситуация двоякая: с одной стороны не было
        использовано сложных концепций, вроде замудренных паттернов проектирования, лишних классов и
        сущностей, но с другой стороны сама система стремительно росла «вширь» и становилась все сложнее и
        сложнее для восприятия. Поэтому этот принцип должен быть использован осторожно, а не воспринят
        буквально!</p>
      <h3>Принцип DRY</h3>
      <figure style="width: 300px" class="alignright">
        <img src="./Page_files/kopipasta-300x209.jpg" alt="Самое мощное оружие говнокодера">
        <figcaption class="wp-caption-text">Самое мощное оружие говнокодера</figcaption>
      </figure>
      <p>Don’t Repeat Yourself — тут все просто. Если код повторяется более двух раз — создаем более
        абстрактный код. Выносим код в функцию и параметризуем его, создаем класс…что угодно! У меня код
        просчета врагов копировался минимум 4 раза. И вообще, Ctrl+C, Ctrl-V было самым мощным инструментом
        разработки (как я тогда считал). Ничто не могло сравниться с копированием 2000 строк <a
          href="https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B0%D0%B3%D0%B5%D1%82%D1%82%D0%B8-%D0%BA%D0%BE%D0%B4"
          target="_blank" rel="nofollow noopener">спагетти-кода</a> и замены одних магических значений переменных на другие.</p>
      <h3>Паттерны программирования</h3>
      <p>Что? Вы серьезно? Какие паттерны? Я и о классах тогда не знал.</p>
      <p>Хотя и меня сейчас возникают сомнения: возможно этот код является адаптером для открытия врат ада на С++.</p>
      <h1>Немного графики</h1>
      <h3>Задний фон</h3>
      <figure style="width: 300px" class="alignright">
        <img src="./Page_files/fon-300x225.png">
        <figcaption class="wp-caption-text">Первая приятная текстура травы, которую я использовал для фона игрового уровня</figcaption>
      </figure>
      <p>С задним фоном были проблемы. Текстура травы выбивалась из общего стиля и выглядела как нелепо
        вклеенная фотография. Конечно, выглядела она приятно и приемлемо, но не совсем идеально.</p>
      <p>Чтобы добавить объемности игре я сначала решил добавить небо (скриншот был в описании игрового
        уровня). Это была натянутая длинная текстура с шириной намного больше экрана, которая медленно
        постепенно перемещалась, в зависимости от местонахождения игрока на уровне. Выглядело вполне приятно,
        но это сломало геймплей — стало совсем легко играть, так как зайцы теперь бегали не по всей площади
        поля, а по оставшимся 70-80%. Хотя, сначала они бегали и по небу, да.</p>
      <figure style="width: 300px" class="alignleft">
        <img src="./Page_files/fon_trava_pojuxlaya-300x225.png">
        <figcaption class="wp-caption-text">Конечный вариант мультяшной пиксель-арт текстуры</figcaption>
      </figure>
      <p>Затем я удалил небо и решил кардинально изменить графику фона — решил попробовать не фотографию, а
        рисованную однотонную текстуру с небольшими повторяющимися элементами. Вышло очень круто, притом при
        минимальном затрате сил, поэтому это был конечный вариант.</p>
      <p>Кстати, с похожей вещью я столкнулся сравнительно недавно и при разработке сайтов — если использовать
        для фона текстуру-фотографию со слишком бросающимся в глаза узором, то что бы Вы ни делали,
        впечатление от сайта кардинально меняется. Я использовал текстуру старой бумаги, в итоге сайт выглядел
        как сборник сказок, что бы я туда ни писал (сайт был коммерческим, но с упором на классический стиль).
        В итоге я заменил текстуру на однотонные блоки, и он стал выглядеть просто обалденно! Возьмите себе
        это на заметку — если не нравится фон, попробуйте что-то попроще.</p>
      <h3>Шрифт</h3>
      <p>Для игры я использовал свой фирменный шрифт, который я разработал в фотошопе. Конечно же на основе
        Comic Sans! Кстати, <a href="https://webdesignledger.com/3-reasons-why-you-shouldnt-hate-comic-sans/"
          target="_blank" rel="nofollow noopener">здесь отличная статья</a> на английском, почему Вы не должны
        ненавидеть этот шрифт.</p>

      <p>
        <img class="aligncenter" src="./Page_files/bonus_shilo_text.png">
        <img class="aligncenter" src="./Page_files/bonus_ulitka_text.png">
      </p>

      <h3>Объекты уровня</h3>
      <figure style="width: 100px" class="alignleft"><img src="./Page_files/penek1.png" alt="Ты на пенек сел - должен был косарь отдать! (с)">
        <figcaption class="wp-caption-text">Ты на пенек сел — должен был косарь отдать! (с)</figcaption>
      </figure>
      <p>Больше всего времени, из статичных рисунков, я потратил на рисование дерева. Не помню точно, сколько
        ушло времени, но примерно часов 5 точно. Это, конечно же, был пиксель-арт, который я рисовал «из
        головы».</p>
      <h1>Послесловие</h1>
      <p>Какие уроки можно вывести из этого проекта?</p>
      <p>Во-первых, ставьте реальные и четкие цели. Если не можете оценить цель по реальности, попробуйте ее
        хотя бы четко очертить. Если и это невозможно — перед Вами очередная «что бы такого запилить чтоб все
        обалдели» цель. Избегайте таких целей.</p>
      <p>Всегда при постановке цели спрашивайте себя «зачем?». Если ответа нет — то это и не цель, это
        прихоть. Если ответ размазан — будьте честны с самим собой, скорее всего эта цель просто потешит Ваше
        ЧСВ. По-хорошему, приступая к новому проекту у Вас может быть две цели: Вам нужно либо заработать
        денег (что у начинающего программиста оооочень редко удается), либо научиться чему-либо.</p>
      <p>Во-вторых, подходите к делу грамотно. Если чувствуете, что чего-то не знаете — попробуйте хотя бы
        поверхностно разобраться. Если бы я хотя бы немного разобрался в классах и ООП, то проблем было бы на
        порядок меньше. Не пренебрегайте необходимыми знаниями.</p>
      <p>Да, есть проблема того, что можно и не знать того факта, что Вы что-то не знаете или недопонимаете.
        Но как раз с такими вот моментами я и рекомендую разобраться.</p>
      <p>В-третьих, начинайте с малого, если Вы новичок. А в разработке игр это правило надо высечь золотыми
        буквами. Сейчас, даже имея за плечами восьмилетний опыт программирования я бы не взялся за такой
        проект. Хочется сделать что-то казуальное и простое, как тетрис (все у меня через задницу!), так как
        это быстрее разрабатывается и легче окупается.</p>
      <p><strong>За сим откланяюсь, предложения по улучшению статьи и отзывы можете оставлять в
          комментариях!</strong></p>
    </div>
  </div>
</body>

</html>